{
  "easy": [
    {
      "id": "A1",
      "title": "1. Two Sum",
      "description": "# 1. Two Sum\n\n## 題目\n給定一個整數陣列 nums 和目標值 target,找出陣列中兩個數字相加等於 target 的索引。\n\n## 面試重點\n經典的 HashMap 空間換時間題目,測試是否理解如何用額外空間將 O(n²) 優化為 O(n)。\n面試官會注意邊界處理,例如同一元素不能使用兩次。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(n)\n\n## Follow-up\n- 若陣列已排序,能否用雙指標做到 O(1) 空間?\n- 若有多組解,如何回傳所有配對?",
      "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    \n    return []",
      "difficulty": "easy"
    },
    {
      "id": "A2",
      "title": "2. Valid Anagram",
      "description": "# 2. Valid Anagram\n\n## 題目\n給定兩個字串 s 與 t，判斷 t 是否為 s 的 anagram（字元組成相同，順序可不同）。\n\n## 面試重點\n此題測試基本字串遍歷與字元計數能力，是 HashMap 應用的入門題。\n面試官會觀察是否能將排序解法優化為線性時間，並正確處理字元計數與減法。\n\n## 複雜度\n時間複雜度：O(n)\n空間複雜度：O(k)，k 為字元種類數\n\n## Follow-up\n- 若只包含小寫英文字母，是否能用 array 取代 HashMap？\n- 若是 Unicode 字元，空間複雜度如何影響？",
      "code": "def is_anagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n\n    count = {}\n    for c in s:\n        count[c] = count.get(c, 0) + 1\n\n    for c in t:\n        if c not in count or count[c] == 0:\n            return False\n        count[c] -= 1\n\n    return True",
      "difficulty": "easy"
    },
    {
      "id": "A3",
      "title": "3. Best Time to Buy and Sell Stock",
      "description": "# 3. Best Time to Buy and Sell Stock\n\n## 題目\n給定陣列 prices,prices[i] 是第 i 天的股票價格。選擇某一天買入,在未來某天賣出,計算最大利潤。\n\n## 面試重點\n此題測試動態維護最小值與最大差值的能力,是一次遍歷問題的典型代表。\n面試官會觀察是否能避免巢狀迴圈,用單次掃描解決。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(1)\n\n## Follow-up\n- 若可以進行多次交易(但不能同時持有兩筆),該如何修改?\n- 若有交易手續費,演算法如何調整?",
      "code": "def max_profit(prices: list[int]) -> int:\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    \n    return max_profit",
      "difficulty": "easy"
    },
    {
      "id": "A4",
      "title": "4. Majority Element",
      "description": "# 4. Majority Element\n\n## 題目\n給定大小為 n 的陣列,找出出現次數超過 ⌊n/2⌋ 的元素(保證存在)。\n\n## 面試重點\n此題測試 Boyer-Moore 投票演算法的理解,是常數空間解法的經典應用。\n面試官會先讓你用 HashMap 解,再追問能否優化到 O(1) 空間。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(1)\n\n## Follow-up\n- 若不保證存在 majority element,如何驗證結果?\n- 若要找出現次數超過 ⌊n/3⌋ 的所有元素,該如何修改?",
      "code": "def majority_element(nums: list[int]) -> int:\n    candidate = None\n    count = 0\n    \n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += 1 if num == candidate else -1\n    \n    return candidate",
      "difficulty": "easy"
    },
    {
      "id": "A5",
      "title": "5. Merge Sorted Array",
      "description": "# 5. Merge Sorted Array\n\n## 題目\n給定兩個已排序陣列 nums1 和 nums2,將 nums2 合併到 nums1 中,使 nums1 成為排序陣列。\nnums1 有足夠空間容納兩個陣列的所有元素。\n\n## 面試重點\n此題測試從後往前填充的技巧,避免額外空間與元素覆蓋問題。\n面試官會觀察是否能想到逆向思維,從尾部開始合併。\n\n## 複雜度\n時間複雜度:O(m + n)\n空間複雜度:O(1)\n\n## Follow-up\n- 若 nums1 沒有額外空間,該如何處理?\n- 若要合併 k 個已排序陣列,會用什麼資料結構?",
      "code": "def merge(nums1: list[int], m: int, nums2: list[int], n: int) -> None:\n    i, j, k = m - 1, n - 1, m + n - 1\n    \n    while j >= 0:\n        if i >= 0 and nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1",
      "difficulty": "easy"
    },
    {
      "id": "A6",
      "title": "6. Reverse Linked List",
      "description": "# 6. Reverse Linked List\n\n## 題目\n反轉一個單向鏈結串列,回傳反轉後的頭節點。\n\n## 面試重點\n此題是 LinkedList 操作的基礎,測試指標操作與迭代/遞迴兩種思維。\n面試官通常會要求同時寫出迭代與遞迴版本。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(1) 迭代版,O(n) 遞迴版\n\n## Follow-up\n- 能否用遞迴實作?空間複雜度的差異?\n- 若要反轉特定區間 [left, right],該如何修改?",
      "code": "def reverse_list(head: ListNode) -> ListNode:\n    prev = None\n    curr = head\n    \n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    return prev",
      "difficulty": "easy"
    },
    {
      "id": "A7",
      "title": "7. Merge Two Sorted Lists",
      "description": "# 7. Merge Two Sorted Lists\n\n## 題目\n合併兩個已排序的鏈結串列,回傳合併後的新鏈結串列頭節點。\n\n## 面試重點\n此題測試 dummy node 技巧與雙指標遍歷,是鏈結串列合併的標準模板。\n面試官會觀察邊界處理,例如其中一個串列為空的情況。\n\n## 複雜度\n時間複雜度:O(m + n)\n空間複雜度:O(1)\n\n## Follow-up\n- 能否用遞迴實作?\n- 若要合併 k 個已排序鏈結串列,該用什麼方法?",
      "code": "def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    current = dummy\n    \n    while l1 and l2:\n        if l1.val < l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    \n    current.next = l1 if l1 else l2\n    return dummy.next",
      "difficulty": "easy"
    },
    {
      "id": "A8",
      "title": "8. Linked List Cycle",
      "description": "# 8. Linked List Cycle\n\n## 題目\n給定一個鏈結串列,判斷其中是否有環(cycle)。\n\n## 面試重點\n此題測試 Floyd's Cycle Detection(快慢指標)演算法,是空間優化的經典案例。\n面試官會先讓你用 HashSet 解,再追問 O(1) 空間解法。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(1)\n\n## Follow-up\n- 若要找出環的起始節點,該如何修改?\n- 若要計算環的長度,該如何實作?",
      "code": "def has_cycle(head: ListNode) -> bool:\n    if not head:\n        return False\n    \n    slow = head\n    fast = head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    \n    return False",
      "difficulty": "easy"
    },
    {
      "id": "A9",
      "title": "9. Maximum Depth of Binary Tree",
      "description": "# 9. Maximum Depth of Binary Tree\n\n## 題目\n給定一個二元樹,找出其最大深度(從根節點到最遠葉節點的路徑長度)。\n\n## 面試重點\n此題是樹遞迴的入門題,測試對樹結構的基本理解與遞迴思維。\n面試官會觀察是否能清楚表達遞迴的終止條件與遞迴關係。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(h),h 為樹高\n\n## Follow-up\n- 能否用迭代(BFS/DFS)實作?\n- 若要找最小深度,終止條件有何不同?",
      "code": "def max_depth(root: TreeNode) -> int:\n    if not root:\n        return 0\n    \n    left_depth = max_depth(root.left)\n    right_depth = max_depth(root.right)\n    \n    return max(left_depth, right_depth) + 1",
      "difficulty": "easy"
    },
    {
      "id": "A10",
      "title": "10. Invert Binary Tree",
      "description": "# 10. Invert Binary Tree\n\n## 題目\n給定一個二元樹的根節點,將整棵樹左右翻轉。\n\n## 面試重點\n此題測試樹的遞迴修改,是理解 in-place 操作的基礎題。\n面試官會觀察是否能用簡潔的遞迴或迭代方式實作。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(h)\n\n## Follow-up\n- 能否用 BFS 迭代實作?\n- 若樹非常大,如何避免遞迴 stack overflow?",
      "code": "def invert_tree(root: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    \n    root.left, root.right = root.right, root.left\n    \n    invert_tree(root.left)\n    invert_tree(root.right)\n    \n    return root",
      "difficulty": "easy"
    },
    {
      "id": "A11",
      "title": "11. Same Tree",
      "description": "# 11. Same Tree\n\n## 題目\n給定兩個二元樹的根節點 p 和 q,判斷它們是否結構相同且節點值相等。\n\n## 面試重點\n此題測試樹的遞迴比較,是理解同步遍歷的基礎。\n面試官會觀察邊界條件處理,例如一個為空另一個不為空。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(h)\n\n## Follow-up\n- 能否用迭代方式實作?\n- 若要判斷是否為對稱樹,該如何修改?",
      "code": "def is_same_tree(p: TreeNode, q: TreeNode) -> bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    \n    if p.val != q.val:\n        return False\n    \n    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)",
      "difficulty": "easy"
    },
    {
      "id": "A12",
      "title": "12. Binary Tree Level Order Traversal",
      "description": "# 12. Binary Tree Level Order Traversal\n\n## 題目\n給定二元樹的根節點,回傳其節點值的層序遍歷(由上到下,每層由左到右)。\n\n## 面試重點\n此題是 BFS 的標準應用,測試 queue 的使用與層級分離技巧。\n面試官會觀察是否能正確記錄每層的節點數,避免層級混淆。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(w),w 為最大寬度\n\n## Follow-up\n- 能否用 DFS 實作層序遍歷?\n- 若要鋸齒狀層序遍歷(奇數層反向),該如何修改?",
      "code": "def level_order(root: TreeNode) -> list[list[int]]:\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        level_size = len(queue)\n        current_level = []\n        \n        for _ in range(level_size):\n            node = queue.pop(0)\n            current_level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(current_level)\n    \n    return result",
      "difficulty": "easy"
    },
    {
      "id": "A13",
      "title": "13. Binary Search",
      "description": "# 13. Binary Search\n\n## 題目\n給定一個已排序陣列 nums 與目標值 target,若 target 存在於陣列中,回傳其索引,否則回傳 -1。\n\n## 面試重點\n此題是二分搜尋的標準模板,測試對搜尋空間縮減的理解。\n面試官會特別注意邊界條件,例如 left/right 指標的更新方式,避免無窮迴圈。\n\n## 複雜度\n時間複雜度:O(log n)\n空間複雜度:O(1)\n\n## Follow-up\n- 若陣列有重複元素,如何找第一個/最後一個出現位置?\n- 若要在旋轉排序陣列中搜尋,該如何修改?",
      "code": "def binary_search(nums: list[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1",
      "difficulty": "easy"
    },
    {
      "id": "A14",
      "title": "14. First Bad Version",
      "description": "# 14. First Bad Version\n\n## 題目\n假設你是產品經理,有 n 個版本 [1, 2, ..., n],從某個版本開始都是壞的。\n給定 API isBadVersion(version),找出第一個壞版本,最小化 API 呼叫次數。\n\n## 面試重點\n此題是二分搜尋的變形,測試在搜尋邊界模糊時的處理能力。\n面試官會觀察如何正確收斂到第一個滿足條件的位置。\n\n## 複雜度\n時間複雜度:O(log n)\n空間複雜度:O(1)\n\n## Follow-up\n- 若 isBadVersion 呼叫成本很高,如何進一步減少呼叫次數?\n- 若版本號不連續,該如何調整演算法?",
      "code": "def first_bad_version(n: int) -> int:\n    left, right = 1, n\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        if isBadVersion(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left",
      "difficulty": "easy"
    },
    {
      "id": "A15",
      "title": "15. Search Insert Position",
      "description": "# 15. Search Insert Position\n\n## 題目\n給定已排序陣列與目標值,找出目標值在陣列中的索引。若不存在,回傳它應該插入的位置。\n\n## 面試重點\n此題測試二分搜尋的邊界處理,特別是找不到時的插入位置判斷。\n面試官會觀察最後 left 指標的位置是否就是插入點。\n\n## 複雜度\n時間複雜度:O(log n)\n空間複雜度:O(1)\n\n## Follow-up\n- 若陣列有重複元素,如何找到插入後保持穩定排序的位置?\n- 若要找大於 target 的最小元素,該如何修改?",
      "code": "def search_insert(nums: list[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left",
      "difficulty": "easy"
    },
    {
      "id": "A16",
      "title": "16. Valid Parentheses",
      "description": "# 16. Valid Parentheses\n\n## 題目\n給定只包含 '(', ')', '{', '}', '[', ']' 的字串,判斷括號是否有效匹配。\n\n## 面試重點\n此題是 Stack 的經典應用,測試配對問題的基本思維。\n面試官會觀察是否能正確處理不匹配的各種情況(多餘左括號、多餘右括號、類型不匹配)。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(n)\n\n## Follow-up\n- 若字串包含其他字元,如何忽略非括號字元?\n- 若要找出最長有效括號子字串,該用什麼方法?",
      "code": "def is_valid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            top = stack.pop() if stack else '#'\n            if mapping[char] != top:\n                return False\n        else:\n            stack.append(char)\n    \n    return not stack",
      "difficulty": "easy"
    },
    {
      "id": "A17",
      "title": "17. Implement Queue using Stacks",
      "description": "# 17. Implement Queue using Stacks\n\n## 題目\n用兩個 stack 實作 queue,支援 push、pop、peek、empty 操作。\n\n## 面試重點\n此題測試資料結構轉換的理解,特別是如何用 LIFO 模擬 FIFO。\n面試官會觀察是否理解 amortized O(1) 的概念,以及何時進行元素轉移。\n\n## 複雜度\n時間複雜度:push O(1),pop/peek amortized O(1)\n空間複雜度:O(n)\n\n## Follow-up\n- 能否用一個 stack 實作 queue?\n- 若用 queue 實作 stack,該如何設計?",
      "code": "class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n    \n    def push(self, x: int) -> None:\n        self.stack_in.append(x)\n    \n    def pop(self) -> int:\n        self._move()\n        return self.stack_out.pop()\n    \n    def peek(self) -> int:\n        self._move()\n        return self.stack_out[-1]\n    \n    def empty(self) -> bool:\n        return not self.stack_in and not self.stack_out\n    \n    def _move(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())",
      "difficulty": "easy"
    },
    {
      "id": "A18",
      "title": "18. Min Stack",
      "description": "# 18. Min Stack\n\n## 題目\n設計一個支援 push、pop、top 和在常數時間內取得最小元素的 stack。\n\n## 面試重點\n此題測試輔助資料結構的設計,是空間換時間的典型應用。\n面試官會觀察是否能用額外 stack 同步維護最小值,或用元組存儲。\n\n## 複雜度\n時間複雜度:所有操作 O(1)\n空間複雜度:O(n)\n\n## Follow-up\n- 能否優化空間,只在最小值變化時存儲?\n- 若要支援 getMax,該如何修改?",
      "code": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self) -> None:\n        if self.stack.pop() == self.min_stack[-1]:\n            self.min_stack.pop()\n    \n    def top(self) -> int:\n        return self.stack[-1]\n    \n    def get_min(self) -> int:\n        return self.min_stack[-1]",
      "difficulty": "easy"
    },
    {
      "id": "A19",
      "title": "19. Climbing Stairs",
      "description": "# 19. Climbing Stairs\n\n## 題目\n爬樓梯到第 n 階,每次可以爬 1 或 2 階,計算有多少種不同的方法爬到頂端。\n\n## 面試重點\n此題是動態規劃的入門題,實質上是 Fibonacci 數列。\n面試官會觀察是否能從遞迴優化到迭代,並理解狀態轉移方程。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(1)\n\n## Follow-up\n- 若每次可以爬 1、2 或 3 階,該如何修改?\n- 能否用矩陣快速冪優化到 O(log n)?",
      "code": "def climb_stairs(n: int) -> int:\n    if n <= 2:\n        return n\n    \n    prev2, prev1 = 1, 2\n    \n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1",
      "difficulty": "easy"
    },
    {
      "id": "A20",
      "title": "20. Maximum Subarray",
      "description": "# 20. Maximum Subarray\n\n## 題目\n給定整數陣列 nums,找出總和最大的連續子陣列,回傳其總和。\n\n## 面試重點\n此題是 Kadane's Algorithm 的經典應用,測試動態規劃的貪心思維。\n面試官會觀察是否能理解「當前和為負時重新開始」的核心邏輯。\n\n## 複雜度\n時間複雜度:O(n)\n空間複雜度:O(1)\n\n## Follow-up\n- 若要回傳子陣列的起始與結束索引,該如何修改?\n- 若是環形陣列,該如何處理?",
      "code": "def max_subarray(nums: list[int]) -> int:\n    max_sum = nums[0]\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum",
      "difficulty": "easy"
    }
  ],
  "medium": [],
  "hard": []
}