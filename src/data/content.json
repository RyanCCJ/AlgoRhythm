{
  "easy": [
    {
      "id": "A1",
      "title": "1. Two Sum",
      "description": "# 1. Two Sum\n\n## 題目\n給定一個整數陣列 nums 和目標值 target,找出陣列中兩個數字相加等於 target 的索引。\n\n## 面試重點\n經典的 HashMap 空間換時間題目,測試是否理解如何用額外空間將 O(n²) 優化為 O(n)。\n面試官會注意邊界處理,例如同一元素不能使用兩次。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(n)\n\n## Follow-up\n- 若陣列已排序,能否用雙指標做到 O(1) 空間?\n- 若有多組解,如何回傳所有配對?",
      "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    \n    return []",
      "difficulty": "easy"
    },
    {
      "id": "A2",
      "title": "2. Valid Anagram",
      "description": "# 2. Valid Anagram\n\n## 題目\n給定兩個字串 s 與 t，判斷 t 是否為 s 的 anagram（字元組成相同，順序可不同）。\n\n## 面試重點\n此題測試基本字串遍歷與字元計數能力，是 HashMap 應用的入門題。\n面試官會觀察是否能將排序解法優化為線性時間，並正確處理字元計數與減法。\n\n## 複雜度\n- 時間複雜度：O(n)\n- 空間複雜度：O(k)，k 為字元種類數\n\n## Follow-up\n- 若只包含小寫英文字母，是否能用 array 取代 HashMap？\n- 若是 Unicode 字元，空間複雜度如何影響？",
      "code": "def is_anagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    count = {}\n    for c in s:\n        count[c] = count.get(c, 0) + 1\n    \n    for c in t:\n        if c not in count or count[c] == 0:\n            return False\n        count[c] -= 1\n    \n    return True",
      "difficulty": "easy"
    },
    {
      "id": "A3",
      "title": "3. Best Time to Buy and Sell Stock",
      "description": "# 3. Best Time to Buy and Sell Stock\n\n## 題目\n給定陣列 prices,prices[i] 是第 i 天的股票價格。選擇某一天買入,在未來某天賣出,計算最大利潤。\n\n## 面試重點\n此題測試動態維護最小值與最大差值的能力,是一次遍歷問題的典型代表。\n面試官會觀察是否能避免巢狀迴圈,用單次掃描解決。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若可以進行多次交易(但不能同時持有兩筆),該如何修改?\n- 若有交易手續費,演算法如何調整?",
      "code": "def max_profit(prices: list[int]) -> int:\n    min_price = float('inf')\n    max_profit = 0\n\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    \n    return max_profit",
      "difficulty": "easy"
    },
    {
      "id": "A4",
      "title": "4. Majority Element",
      "description": "# 4. Majority Element\n\n## 題目\n給定大小為 n 的陣列,找出出現次數超過 ⌊n/2⌋ 的元素(保證存在)。\n\n## 面試重點\n此題測試 Boyer-Moore 投票演算法的理解,是常數空間解法的經典應用。\n面試官會先讓你用 HashMap 解,再追問能否優化到 O(1) 空間。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若不保證存在 majority element,如何驗證結果?\n- 若要找出現次數超過 ⌊n/3⌋ 的所有元素,該如何修改?",
      "code": "def majority_element(nums: list[int]) -> int:\n    candidate = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += 1 if num == candidate else -1\n    \n    return candidate",
      "difficulty": "easy"
    },
    {
      "id": "A5",
      "title": "5. Merge Sorted Array",
      "description": "# 5. Merge Sorted Array\n\n## 題目\n給定兩個已排序陣列 nums1 和 nums2,將 nums2 合併到 nums1 中,使 nums1 成為排序陣列。\nnums1 有足夠空間容納兩個陣列的所有元素。\n\n## 面試重點\n此題測試從後往前填充的技巧,避免額外空間與元素覆蓋問題。\n面試官會觀察是否能想到逆向思維,從尾部開始合併。\n\n## 複雜度\n- 時間複雜度:O(m + n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若 nums1 沒有額外空間,該如何處理?\n- 若要合併 k 個已排序陣列,會用什麼資料結構?",
      "code": "def merge(nums1: list[int], m: int, nums2: list[int], n: int) -> None:\n    i, j, k = m - 1, n - 1, m + n - 1\n    \n    while j >= 0:\n        if i >= 0 and nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1",
      "difficulty": "easy"
    },
    {
      "id": "A6",
      "title": "6. Reverse Linked List",
      "description": "# 6. Reverse Linked List\n\n## 題目\n反轉一個單向鏈結串列,回傳反轉後的頭節點。\n\n## 面試重點\n此題是 LinkedList 操作的基礎,測試指標操作與迭代/遞迴兩種思維。\n面試官通常會要求同時寫出迭代與遞迴版本。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(1) 迭代版,O(n) 遞迴版\n\n## Follow-up\n- 能否用遞迴實作?空間複雜度的差異?\n- 若要反轉特定區間 [left, right],該如何修改?",
      "code": "def reverse_list(head: ListNode) -> ListNode:\n    prev = None\n    curr = head\n\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    return prev",
      "difficulty": "easy"
    },
    {
      "id": "A7",
      "title": "7. Merge Two Sorted Lists",
      "description": "# 7. Merge Two Sorted Lists\n\n## 題目\n合併兩個已排序的鏈結串列,回傳合併後的新鏈結串列頭節點。\n\n## 面試重點\n此題測試 dummy node 技巧與雙指標遍歷,是鏈結串列合併的標準模板。\n面試官會觀察邊界處理,例如其中一個串列為空的情況。\n\n## 複雜度\n- 時間複雜度:O(m + n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 能否用遞迴實作?\n- 若要合併 k 個已排序鏈結串列,該用什麼方法?",
      "code": "def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    current = dummy\n\n    while l1 and l2:\n        if l1.val < l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    \n    current.next = l1 if l1 else l2\n    return dummy.next",
      "difficulty": "easy"
    },
    {
      "id": "A8",
      "title": "8. Linked List Cycle",
      "description": "# 8. Linked List Cycle\n\n## 題目\n給定一個鏈結串列,判斷其中是否有環(cycle)。\n\n## 面試重點\n此題測試 Floyd's Cycle Detection(快慢指標)演算法,是空間優化的經典案例。\n面試官會先讓你用 HashSet 解,再追問 O(1) 空間解法。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若要找出環的起始節點,該如何修改?\n- 若要計算環的長度,該如何實作?",
      "code": "def has_cycle(head: ListNode) -> bool:\n    if not head:\n        return False\n    \n    slow = head\n    fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    \n    return False",
      "difficulty": "easy"
    },
    {
      "id": "A9",
      "title": "9. Maximum Depth of Binary Tree",
      "description": "# 9. Maximum Depth of Binary Tree\n\n## 題目\n給定一個二元樹,找出其最大深度(從根節點到最遠葉節點的路徑長度)。\n\n## 面試重點\n此題是樹遞迴的入門題,測試對樹結構的基本理解與遞迴思維。\n面試官會觀察是否能清楚表達遞迴的終止條件與遞迴關係。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(h),h 為樹高\n\n## Follow-up\n- 能否用迭代(BFS/DFS)實作?\n- 若要找最小深度,終止條件有何不同?",
      "code": "def max_depth(root: TreeNode) -> int:\n    if not root:\n        return 0\n    \n    left_depth = max_depth(root.left)\n    right_depth = max_depth(root.right)\n    \n    return max(left_depth, right_depth) + 1",
      "difficulty": "easy"
    },
    {
      "id": "A10",
      "title": "10. Invert Binary Tree",
      "description": "# 10. Invert Binary Tree\n\n## 題目\n給定一個二元樹的根節點,將整棵樹左右翻轉。\n\n## 面試重點\n此題測試樹的遞迴修改,是理解 in-place 操作的基礎題。\n面試官會觀察是否能用簡潔的遞迴或迭代方式實作。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(h)\n\n## Follow-up\n- 能否用 BFS 迭代實作?\n- 若樹非常大,如何避免遞迴 stack overflow?",
      "code": "def invert_tree(root: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    \n    root.left, root.right = root.right, root.left\n\n    invert_tree(root.left)\n    invert_tree(root.right)\n    \n    return root",
      "difficulty": "easy"
    },
    {
      "id": "A11",
      "title": "11. Same Tree",
      "description": "# 11. Same Tree\n\n## 題目\n給定兩個二元樹的根節點 p 和 q,判斷它們是否結構相同且節點值相等。\n\n## 面試重點\n此題測試樹的遞迴比較,是理解同步遍歷的基礎。\n面試官會觀察邊界條件處理,例如一個為空另一個不為空。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(h)\n\n## Follow-up\n- 能否用迭代方式實作?\n- 若要判斷是否為對稱樹,該如何修改?",
      "code": "def is_same_tree(p: TreeNode, q: TreeNode) -> bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    \n    if p.val != q.val:\n        return False\n    \n    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)",
      "difficulty": "easy"
    },
    {
      "id": "A12",
      "title": "12. Binary Tree Level Order Traversal",
      "description": "# 12. Binary Tree Level Order Traversal\n\n## 題目\n給定二元樹的根節點,回傳其節點值的層序遍歷(由上到下,每層由左到右)。\n\n## 面試重點\n此題是 BFS 的標準應用,測試 queue 的使用與層級分離技巧。\n面試官會觀察是否能正確記錄每層的節點數,避免層級混淆。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(w),w 為最大寬度\n\n## Follow-up\n- 能否用 DFS 實作層序遍歷?\n- 若要鋸齒狀層序遍歷(奇數層反向),該如何修改?",
      "code": "def level_order(root: TreeNode) -> list[list[int]]:\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.pop(0)\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(current_level)\n    \n    return result",
      "difficulty": "easy"
    },
    {
      "id": "A13",
      "title": "13. Binary Search",
      "description": "# 13. Binary Search\n\n## 題目\n給定一個已排序陣列 nums 與目標值 target,若 target 存在於陣列中,回傳其索引,否則回傳 -1。\n\n## 面試重點\n此題是二分搜尋的標準模板,測試對搜尋空間縮減的理解。\n面試官會特別注意邊界條件,例如 left/right 指標的更新方式,避免無窮迴圈。\n\n## 複雜度\n- 時間複雜度:O(log n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若陣列有重複元素,如何找第一個/最後一個出現位置?\n- 若要在旋轉排序陣列中搜尋,該如何修改?",
      "code": "def binary_search(nums: list[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1",
      "difficulty": "easy"
    },
    {
      "id": "A14",
      "title": "14. First Bad Version",
      "description": "# 14. First Bad Version\n\n## 題目\n假設你是產品經理,有 n 個版本 [1, 2, ..., n],從某個版本開始都是壞的。\n給定 API isBadVersion(version),找出第一個壞版本,最小化 API 呼叫次數。\n\n## 面試重點\n此題是二分搜尋的變形,測試在搜尋邊界模糊時的處理能力。\n面試官會觀察如何正確收斂到第一個滿足條件的位置。\n\n## 複雜度\n- 時間複雜度:O(log n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若 isBadVersion 呼叫成本很高,如何進一步減少呼叫次數?\n- 若版本號不連續,該如何調整演算法?",
      "code": "def first_bad_version(n: int) -> int:\n    left, right = 1, n\n\n    while left < right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left",
      "difficulty": "easy"
    },
    {
      "id": "A15",
      "title": "15. Search Insert Position",
      "description": "# 15. Search Insert Position\n\n## 題目\n給定已排序陣列與目標值,找出目標值在陣列中的索引。若不存在,回傳它應該插入的位置。\n\n## 面試重點\n此題測試二分搜尋的邊界處理,特別是找不到時的插入位置判斷。\n面試官會觀察最後 left 指標的位置是否就是插入點。\n\n## 複雜度\n- 時間複雜度:O(log n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若陣列有重複元素,如何找到插入後保持穩定排序的位置?\n- 若要找大於 target 的最小元素,該如何修改?",
      "code": "def search_insert(nums: list[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left",
      "difficulty": "easy"
    },
    {
      "id": "A16",
      "title": "16. Valid Parentheses",
      "description": "# 16. Valid Parentheses\n\n## 題目\n給定只包含 '(', ')', '{', '}', '[', ']' 的字串,判斷括號是否有效匹配。\n\n## 面試重點\n此題是 Stack 的經典應用,測試配對問題的基本思維。\n面試官會觀察是否能正確處理不匹配的各種情況(多餘左括號、多餘右括號、類型不匹配)。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(n)\n\n## Follow-up\n- 若字串包含其他字元,如何忽略非括號字元?\n- 若要找出最長有效括號子字串,該用什麼方法?",
      "code": "def is_valid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n\n    for char in s:\n        if char in mapping:\n            top = stack.pop() if stack else '#'\n            if mapping[char] != top:\n                return False\n        else:\n            stack.append(char)\n    \n    return not stack",
      "difficulty": "easy"
    },
    {
      "id": "A17",
      "title": "17. Implement Queue using Stacks",
      "description": "# 17. Implement Queue using Stacks\n\n## 題目\n用兩個 stack 實作 queue,支援 push、pop、peek、empty 操作。\n\n## 面試重點\n此題測試資料結構轉換的理解,特別是如何用 LIFO 模擬 FIFO。\n面試官會觀察是否理解 amortized O(1) 的概念,以及何時進行元素轉移。\n\n## 複雜度\n- 時間複雜度:push O(1),pop/peek amortized O(1)\n- 空間複雜度:O(n)\n\n## Follow-up\n- 能否用一個 stack 實作 queue?\n- 若用 queue 實作 stack,該如何設計?",
      "code": "class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n    \n    def push(self, x: int) -> None:\n        self.stack_in.append(x)\n    \n    def pop(self) -> int:\n        self._move()\n        return self.stack_out.pop()\n    \n    def peek(self) -> int:\n        self._move()\n        return self.stack_out[-1]\n    \n    def empty(self) -> bool:\n        return not self.stack_in and not self.stack_out\n    \n    def _move(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())",
      "difficulty": "easy"
    },
    {
      "id": "A18",
      "title": "18. Min Stack",
      "description": "# 18. Min Stack\n\n## 題目\n設計一個支援 push、pop、top 和在常數時間內取得最小元素的 stack。\n\n## 面試重點\n此題測試輔助資料結構的設計,是空間換時間的典型應用。\n面試官會觀察是否能用額外 stack 同步維護最小值,或用元組存儲。\n\n## 複雜度\n- 時間複雜度:所有操作 O(1)\n- 空間複雜度:O(n)\n\n## Follow-up\n- 能否優化空間,只在最小值變化時存儲?\n- 若要支援 getMax,該如何修改?",
      "code": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self) -> None:\n        if self.stack.pop() == self.min_stack[-1]:\n            self.min_stack.pop()\n    \n    def top(self) -> int:\n        return self.stack[-1]\n    \n    def get_min(self) -> int:\n        return self.min_stack[-1]",
      "difficulty": "easy"
    },
    {
      "id": "A19",
      "title": "19. Climbing Stairs",
      "description": "# 19. Climbing Stairs\n\n## 題目\n爬樓梯到第 n 階,每次可以爬 1 或 2 階,計算有多少種不同的方法爬到頂端。\n\n## 面試重點\n此題是動態規劃的入門題,實質上是 Fibonacci 數列。\n面試官會觀察是否能從遞迴優化到迭代,並理解狀態轉移方程。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若每次可以爬 1、2 或 3 階,該如何修改?\n- 能否用矩陣快速冪優化到 O(log n)?",
      "code": "def climb_stairs(n: int) -> int:\n    if n <= 2:\n        return n\n    \n    prev2, prev1 = 1, 2\n\n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1",
      "difficulty": "easy"
    },
    {
      "id": "A20",
      "title": "20. Maximum Subarray",
      "description": "# 20. Maximum Subarray\n\n## 題目\n給定整數陣列 nums,找出總和最大的連續子陣列,回傳其總和。\n\n## 面試重點\n此題是 Kadane's Algorithm 的經典應用,測試動態規劃的貪心思維。\n面試官會觀察是否能理解「當前和為負時重新開始」的核心邏輯。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若要回傳子陣列的起始與結束索引,該如何修改?\n- 若是環形陣列,該如何處理?",
      "code": "def max_subarray(nums: list[int]) -> int:\n    max_sum = nums[0]\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum",
      "difficulty": "easy"
    }
  ],
  "medium": [
    {
      "id": "B1",
      "title": "1. 3Sum",
      "description": "# 1. 3Sum\n\n## 題目\n給定整數陣列 nums,找出所有和為 0 的三元組 [nums[i], nums[j], nums[k]],其中 i、j、k 互不相同。\n結果集不能包含重複的三元組。\n\n## 面試重點\n此題是 Two Sum 的進階版,測試**排序 + 雙指標**的組合技巧。核心難點在於去重邏輯:\n1. 外層迴圈的去重(跳過相同的第一個數)\n2. 雙指標找到解後的去重(跳過相同的第二、三個數)\n\n面試官會特別觀察:\n- 是否先排序以利用有序性質\n- 剪枝優化:當 nums[i] > 0 時可提前終止\n- 去重時是否正確使用 `while` 而非 `if`,避免連續重複\n- 雙指標移動的邊界條件處理\n\n這題是從 O(n³) 暴力法優化到 O(n²) 的典型案例,展現了如何通過排序降低時間複雜度。\n\n## 複雜度\n- 時間複雜度:O(n²)\n- 空間複雜度:O(log n) 或 O(n),取決於排序演算法\n\n## Follow-up\n- 若要找四數之和為 target,該如何擴展?(4Sum)\n- 若不允許排序(需保持原始順序),該用什麼方法?\n- 如何找出最接近 target 的三數之和?",
      "code": "def three_sum(nums: list[int]) -> list[list[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 2):\n\n        if nums[i] > 0:\n            break\n\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total == 0:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                \n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return result",
      "difficulty": "medium"
    },
    {
      "id": "B2",
      "title": "2. Longest Substring Without Repeating Characters",
      "description": "# 2. Longest Substring Without Repeating Characters\n\n## 題目\n給定字串 s, 找出不含重複字元的最長子字串的長度。\n\n## 面試重點\n此題是**滑動窗口(Sliding Window)**的經典應用,測試對窗口伸縮的理解。核心技巧:\n1. 用 HashMap 記錄字元最後出現的位置\n2. 當遇到重複字元時,移動左邊界到重複字元的下一個位置\n3. 持續更新最大長度\n\n面試官會重點觀察:\n- 是否理解「窗口右邊界一直前進,左邊界按需收縮」的模式\n- 更新左邊界時是否正確處理:left = max(left, seen[char] + 1),避免左邊界回退\n- 是否在每次迭代都更新最大長度,而非只在遇到重複時更新\n- 邊界情況:空字串、全部字元相同、全部字元不同\n\n此題展現了從 O(n²) 暴力(檢查每個子字串)到 O(n) 滑動窗口的優化思維。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(min(n, m)),m 為字符集大小\n\n## Follow-up\n- 若限制最多包含 k 個不同字元,該如何修改?\n- 若字串非常長且包含 Unicode,如何優化空間?\n- 若要找包含所有字母至少一次的最短子字串,該用什麼方法?",
      "code": "def length_of_longest_substring(s: str) -> int:\n    seen = {}\n    left = 0\n    max_length = 0\n\n    for right, char in enumerate(s):\n        if char in seen and seen[char] >= left:\n            left = seen[char] + 1\n        seen[char] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length",
      "difficulty": "medium"
    },
    {
      "id": "B3",
      "title": "3. Product of Array Except Self",
      "description": "# 3. Product of Array Except Self\n\n## 題目\n給定整數陣列 nums,回傳陣列 answer,其中 answer[i] 等於 nums 中除了 nums[i] 之外所有元素的乘積。\n要求不使用除法,且時間複雜度為 O(n)。\n\n## 面試重點\n此題測試**前綴積與後綴積**的空間優化技巧,是理解「分解子問題」的典型案例。核心思路:\n1. answer[i] = (i 左邊所有數的乘積) × (i 右邊所有數的乘積)\n2. 用兩次遍歷分別計算左積和右積\n3. 進階:用輸出陣列本身儲存左積,再用單一變數累積右積,達到 O(1) 額外空間\n\n面試官會重點觀察:\n- 是否理解為何不能用總乘積除以當前元素(存在 0 的情況,且題目禁用除法)\n- 能否清楚解釋前綴積的概念:left[i] = nums[0] × ... × nums[i-1]\n- 空間優化:如何將兩個輔助陣列優化為 O(1) 額外空間\n- 對 0 的處理:雖然題目保證在 O(n) 時間內可解,但要思考 0 的影響\n\n此題展現了如何通過**改變遍歷方向和累積變數**來優化空間複雜度。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(1),不計入輸出陣列\n\n## Follow-up\n- 若陣列包含 0,有多少個 0 會如何影響結果?\n- 若允許使用除法,如何處理陣列中有 0 的情況?\n- 若要求 answer[i] 是除了 nums[i] 之外所有元素的和,該如何修改?",
      "code": "def product_except_self(nums: list[int]) -> list[int]:\n    n = len(nums)\n    answer = [1] * n\n\n    left_product = 1\n    for i in range(n):\n        answer[i] = left_product\n        left_product *= nums[i]\n    \n    right_product = 1\n    for i in range(n - 1, -1, -1):\n        answer[i] *= right_product\n        right_product *= nums[i]\n    \n    return answer",
      "difficulty": "medium"
    },
    {
      "id": "B4",
      "title": "4. Container With Most Water",
      "description": "# 4. Container With Most Water\n\n## 題目\n給定 n 個非負整數 height,代表 n 條垂直線,找出兩條線與 x 軸形成的容器,使其容納最多水。\n\n## 面試重點\n此題測試**雙指標 + 貪心策略**,核心洞察是:容器面積受限於較短的邊。移動策略:\n1. 從兩端開始,計算當前面積\n2. 移動較短的邊,因為移動較長的邊不可能得到更大面積\n3. 持續更新最大面積直到雙指標相遇\n\n面試官會重點觀察:\n- 能否解釋為何移動較短邊是貪心的正確選擇\n- 證明:移動較長邊時,寬度減少,高度最多不變(受限於另一邊),面積必然不增\n- 是否理解這是「排除不可能更優解」的思維,而非「直接找到最優解」\n- 時間複雜度從 O(n²) 暴力枚舉到 O(n) 雙指標的優化過程\n\n此題是**雙指標從兩端向中間收縮**模式的代表作,與排序陣列的雙指標不同。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若可以選擇 k 條線,如何找出最大容量?(更複雜的組合問題)\n- 若線有寬度(不是垂直線),該如何計算?\n- 能否用動態規劃解決?為何雙指標更優?",
      "code": "def max_area(height: list[int]) -> int:\n    left, right = 0, len(height) - 1\n    max_water = 0\n\n    while left < right:\n        width = right - left\n        current_height = min(height[left], height[right])\n        max_water = max(max_water, width * current_height)\n\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_water",
      "difficulty": "medium"
    },
    {
      "id": "B5",
      "title": "5. Add Two Numbers",
      "description": "# 5. Add Two Numbers\n\n## 題目\n兩個非空鏈結串列代表兩個非負整數,數字以逆序儲存,每個節點包含一位數字。\n將兩數相加並以相同形式回傳。\n\n## 面試重點\n此題測試**鏈結串列的同步遍歷與進位處理**,核心難點:\n1. 處理不同長度的串列\n2. 正確維護進位(carry)\n3. 最後可能還有進位需要新增節點\n\n面試官會重點觀察:\n- 是否用 dummy node 簡化頭節點處理\n- 迴圈條件:l1 or l2 or carry,確保所有情況都處理\n- 取值時的空指標檢查:val1 = l1.val if l1 else 0\n- 最後進位的處理:迴圈結束後 carry 可能為 1\n- 指標移動的時機:確保不會 NullPointerException\n\n此題展現了**鏈結串列操作的三大技巧**:dummy node、同步遍歷、邊界條件檢查。\n\n## 複雜度\n- 時間複雜度:O(max(m, n))\n- 空間複雜度:O(max(m, n)),輸出串列的長度\n\n## Follow-up\n- 若數字是正序儲存(最高位在前),該如何處理?\n- 若要相加 k 個鏈結串列,該用什麼資料結構?\n- 若數字可能為負數,該如何修改?",
      "code": "def add_two_numbers(l1: ListNode, l2: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    current = dummy\n    carry = 0\n\n    while l1 or l2 or carry:\n        val1 = l1.val if l1 else 0\n        val2 = l2.val if l2 else 0\n\n        total = val1 + val2 + carry\n        carry = total // 10\n        current.next = ListNode(total % 10)\n\n        current = current.next\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n    \n    return dummy.next",
      "difficulty": "medium"
    },
    {
      "id": "B6",
      "title": "6. LRU Cache",
      "description": "# 6. LRU Cache\n\n## 題目\n設計一個 LRU(Least Recently Used)快取,支援 get 和 put 操作,兩者都需要在 O(1) 時間完成。\n容量固定,當達到容量時,移除最久未使用的項目。\n\n## 面試重點\n此題是**雙向鏈結串列 + HashMap** 組合的經典應用,測試複雜資料結構的設計能力。核心設計:\n1. HashMap 提供 O(1) 的 key 查找\n2. 雙向鏈結串列維護訪問順序:最近使用的在頭部,最久未使用的在尾部\n3. 每次訪問都將節點移到頭部,容量滿時移除尾部節點\n\n面試官會重點觀察:\n- 能否解釋為何需要雙向鏈結串列(單向無法 O(1) 刪除)\n- 節點移動的實作:先刪除,再插入頭部\n- dummy head 和 dummy tail 的使用,簡化邊界處理\n- HashMap 和鏈結串列的同步更新:刪除節點時要同時從兩者移除\n- 區分「訪問」和「插入」的邏輯複用\n\n這是系統設計中常見的快取淘汰策略,展現了**如何用組合資料結構達到多維度的 O(1) 操作**。\n\n## 複雜度\n- 時間複雜度:get 和 put 都是 O(1)\n- 空間複雜度:O(capacity)\n\n## Follow-up\n- 若要實作 LFU(Least Frequently Used)快取,該如何設計?\n- 若容量非常大,如何處理記憶體限制?\n- 在多執行緒環境下,如何保證執行緒安全?",
      "code": "class DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self._move_to_head(node)\n        return node.value\n    \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self._move_to_head(node)\n        else:\n            node = DLinkedNode(key, value)\n            self.cache[key] = node\n            self._add_to_head(node)\n            \n            if len(self.cache) > self.capacity:\n                removed = self._remove_tail()\n                del self.cache[removed.key]\n    \n    def _add_to_head(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def _remove_node(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    \n    def _move_to_head(self, node):\n        self._remove_node(node)\n        self._add_to_head(node)\n    \n    def _remove_tail(self):\n        node = self.tail.prev\n        self._remove_node(node)\n        return node",
      "difficulty": "medium"
    },
    {
      "id": "B7",
      "title": "7. Validate Binary Search Tree",
      "description": "# 7. Validate Binary Search Tree\n\n## 題目\n給定二元樹的根節點,判斷其是否為有效的二元搜尋樹(BST)。\nBST 定義:節點的左子樹所有節點值 < 節點值 < 右子樹所有節點值,且左右子樹也都是 BST。\n\n## 面試重點\n此題測試**遞迴時的範圍約束傳遞**,是 BST 驗證的標準模板。常見錯誤:\n1. 只比較父子節點,忽略了整個子樹的約束\n2. 例如:節點值為 5,左子樹某節點為 6,即使 6 > 其父節點 4,但 6 > 5 違反 BST\n\n正確方法:\n1. 遞迴傳遞上下界(min_val, max_val)\n2. 每個節點必須滿足:min_val < node.val < max_val\n3. 向左遞迴時,更新上界為當前節點值\n4. 向右遞迴時,更新下界為當前節點值\n\n面試官會重點觀察:\n- 是否理解 BST 的全域性約束,而非局部性\n- 能否解釋為何需要傳遞上下界\n- 初始呼叫時的邊界值:負無窮到正無窮\n- 中序遍歷解法:利用 BST 中序遍歷為遞增序列的性質\n\n此題展現了**樹的遞迴參數設計**:有時需要額外參數傳遞約束資訊。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(h),遞迴堆疊深度\n\n## Follow-up\n- 若使用中序遍歷,如何驗證?空間複雜度的差異?\n- 若允許重複值,BST 定義如何調整?\n- 若樹非常大,如何做分散式驗證?",
      "code": "def is_valid_bst(root: TreeNode) -> bool:\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        return (validate(node.left, min_val, node.val) and\n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))",
      "difficulty": "medium"
    },
    {
      "id": "B8",
      "title": "8. Lowest Common Ancestor of Binary Tree",
      "description": "\n# 8. Lowest Common Ancestor of Binary Tree\n\n## 題目\n給定二元樹和兩個節點 p 和 q,找出它們的最低共同祖先(LCA)。\nLCA 定義:p 和 q 的共同祖先中,深度最大的節點。\n\n## 面試重點\n此題測試**後序遍歷的回傳值設計**,核心思路是「資訊向上傳遞」:\n1. 如果當前節點是 p 或 q,回傳當前節點\n2. 遞迴左右子樹,檢查是否找到 p 或 q\n3. 如果左右都找到(left != null && right != null),當前節點就是 LCA\n4. 如果只有一邊找到,回傳那一邊的結果(LCA 在該子樹中)\n\n面試官會重點觀察:\n- 能否理解後序遍歷(先處理子樹,再處理當前節點)的必要性\n- 回傳值的語義:null 表示沒找到,非 null 表示找到了 p/q 或 LCA\n- 四種情況的判斷邏輯:\n  - 當前節點是 p 或 q\n  - 左右子樹都找到 → 當前是 LCA\n  - 只有左子樹找到 → LCA 在左子樹\n  - 只有右子樹找到 → LCA 在右子樹\n- 與 BST 的 LCA 區別:BST 可利用大小關係,一般二元樹需要遍歷\n\n此題展現了**如何設計遞迴回傳值來傳遞多重資訊**。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(h),遞迴堆疊深度\n\n## Follow-up\n- 若是 BST,如何利用有序性質優化?\n- 若有父節點指標,能否用 O(1) 空間解決?\n- 若要找 k 個節點的 LCA,該如何修改?",
      "code": "def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    if not root or root == p or root == q:\n        return root\n    \n    left = lowest_common_ancestor(root.left, p, q)\n    right = lowest_common_ancestor(root.right, p, q)\n\n    if left and right:\n        return root\n    \n    return left if left else right",
      "difficulty": "medium"
    },
    {
      "id": "B9",
      "title": "9. Number of Islands",
      "description": "# 9. Number of Islands\n\n## 題目\n給定 m × n 的二維網格,由 '1'(陸地)和 '0'(水)組成,計算島嶼數量。\n島嶼定義:由相鄰的陸地(上下左右)連接而成,周圍被水包圍。\n\n## 面試重點\n此題是**圖的遍歷(DFS/BFS)**在二維網格上的應用,測試連通分量的計算。核心步驟:\n1. 遍歷網格,遇到 '1' 時島嶼數 +1\n2. 從該位置開始 DFS/BFS,將整個島嶼標記為已訪問('0' 或其他標記)\n3. 繼續遍歷,直到檢查完所有格子\n\n面試官會重點觀察:\n- 選擇 DFS 或 BFS,能否解釋兩者差異\n- DFS:遞迴或堆疊,空間複雜度 O(mn) 最壞情況\n- BFS:佇列,適合找最短路徑,空間複雜度 O(min(m,n))\n- 是否需要額外 visited 陣列,還是直接修改原陣列\n- 邊界檢查:越界、已訪問、水域\n- 四個方向的遍歷:常用方向陣列 [(0,1), (1,0), (0,-1), (-1,0)]\n\n此題是**Union-Find(並查集)**的典型應用場景,但 DFS/BFS 更直觀。\n\n## 複雜度\n- 時間複雜度:O(m × n)\n- 空間複雜度:O(m × n),DFS 最壞情況\n\n## Follow-up\n- 若網格非常大,如何分散式處理?\n- 若要計算每個島嶼的面積,該如何修改?\n- 若要找最大的島嶼,該用什麼方法?\n- 能否用 Union-Find 解決?時間複雜度如何?",
      "code": "def num_islands(grid: list[list[str]]) -> int:\n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    count = 0\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0':\n            return\n        \n        grid[i][j] = '0'\n\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n    \n    return count",
      "difficulty": "medium"
    },
    {
      "id": "B10",
      "title": "10. Course Schedule",
      "description": "# 10. Course Schedule\n\n## 題目\n有 n 門課程,編號從 0 到 n-1。給定先修課程關係陣列 prerequisites,其中 [a, b] 表示要修 a 必須先修 b。\n判斷是否可能完成所有課程(即是否存在循環依賴)。\n\n## 面試重點\n此題是**有向圖的拓撲排序與環檢測**,測試圖論的經典演算法。兩種主要方法:\n\n**方法一:DFS 檢測環**\n- 用三種狀態標記:未訪問(0)、訪問中(1)、已完成(2)\n- 訪問中再次遇到 → 存在環\n- 核心:DFS 過程中維護「當前路徑」的狀態\n\n**方法二:BFS 拓撲排序(Kahn's Algorithm)**\n- 計算每個節點的入度\n- 將入度為 0 的節點加入佇列\n- 處理節點時,將其鄰居的入度 -1\n- 若最後處理的節點數 < n,存在環\n\n面試官會重點觀察:\n- 能否正確建立鄰接串列(adjacency list)\n- DFS 三色標記法的理解:白(未訪問)、灰(訪問中)、黑(已完成)\n- BFS 方法中入度陣列的維護\n- 能否解釋拓撲排序的應用場景:依賴關係、任務排程\n- 兩種方法的優劣:DFS 更直觀,BFS 可直接得到拓撲序列\n\n此題是**圖論在實際問題中的應用**:依賴管理、編譯順序、專案排程等。\n\n## 複雜度\n- 時間複雜度:O(V + E),V 為課程數,E 為依賴關係數\n- 空間複雜度:O(V + E),鄰接串列和遞迴堆疊\n\n## Follow-up\n- 若要輸出一個有效的修課順序,該如何修改?\n- 若有多個拓撲排序,如何找出字典序最小的?\n- 若要找出最短的修課學期數(可同時修多門課),該用什麼方法?",
      "code": "# Method 1: DFS cycle detection\ndef can_finish(num_courses: int, prerequisites: list[list[int]]) -> bool:\n    graph = [[] for _ in range(num_courses)]\n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n    \n    state = [0] * num_courses\n\n    def has_cycle(course):\n        if state[course] == 1:\n            return True\n        if state[course] == 2:\n            return False\n        \n        state[course] = 1\n\n        for next_course in graph[course]:\n            if has_cycle(next_course):\n                return True\n        \n        state[course] = 2\n        return False\n    \n    for i in range(num_courses):\n        if has_cycle(i):\n            return False\n    \n    return True\n\n# Method 2: BFS topological sorting\ndef can_finish_bfs(num_courses: int, prerequisites: list[list[int]]) -> bool:\n    graph = [[] for _ in range(num_courses)]\n    indegree = [0] * num_courses\n\n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        indegree[course] += 1\n    \n    queue = [i for i in range(num_courses) if indegree[i] == 0]\n    count = 0\n    \n    while queue:\n        course = queue.pop(0)\n        count += 1\n        \n        for next_course in graph[course]:\n            indegree[next_course] -= 1\n            if indegree[next_course] == 0:\n                queue.append(next_course)\n    \n    return count == num_courses",
      "difficulty": "medium"
    },
    {
      "id": "B11",
      "title": "11. Clone Graph",
      "description": "# 11. Clone Graph\n\n## 題目\n給定無向連通圖中一個節點的引用,回傳該圖的深拷貝(每個節點都是新物件)。\n\n## 面試重點\n此題測試**圖的遍歷與節點複製**,核心難點是處理節點間的循環引用。關鍵技巧:\n1. 用 HashMap 儲存原節點到複製節點的映射,避免重複複製\n2. DFS 或 BFS 遍歷所有節點\n3. 複製節點時,先創建節點本身,再遞迴/迭代複製鄰居\n\n面試官會重點觀察:\n- 能否識別這是圖而非樹(有環)\n- HashMap 的使用:作為「已訪問標記」和「原節點→新節點映射」\n- DFS 遞迴版本:簡潔但可能堆疊溢位\n- BFS 迭代版本:用佇列,空間穩定\n- 複製順序:先創建所有節點,再連接邊 vs 邊創建邊連接\n- 邊界情況:空圖、單節點、完全連接圖\n\n此題展現了**圖遍歷時如何處理已訪問節點與物件複製**的標準模式。\n\n## 複雜度\n- 時間複雜度:O(V + E)\n- 空間複雜度:O(V),HashMap 和遞迴堆疊\n\n## Follow-up\n- 若圖非常大,如何優化記憶體使用?\n- 若圖是有向圖,演算法需要修改嗎?\n- 若需要深拷貝包含其他複雜屬性的圖,該如何設計?",
      "code": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors else []\n\n# DFS\ndef clone_graph(node: Node) -> Node:\n    if not node:\n        return None\n    \n    visited = {}\n\n    def dfs(node):\n        if node in visited:\n            return visited[node]\n        \n        clone = Node(node.val)\n        visited[node] = clone\n\n        for neighbor in node.neighbors:\n            clone.neighbors.append(dfs(neighbor))\n        \n        return clone\n    \n    return dfs(node)\n\n# BFS\ndef clone_graph_bfs(node: Node) -> Node:\n    if not node:\n        return None\n    \n    visited = {node: Node(node.val)}\n    queue = [node]\n\n    while queue:\n        current = queue.pop(0)\n        \n        for neighbor in current.neighbors:\n            if neighbor not in visited:\n                visited[neighbor] = Node(neighbor.val)\n                queue.append(neighbor)\n            \n            visited[current].neighbors.append(visited[neighbor])\n    \n    return visited[node]",
      "difficulty": "medium"
    },
    {
      "id": "B12",
      "title": "12. Search in Rotated Sorted Array",
      "description": "# 12. Search in Rotated Sorted Array\n\n## 題目\n已排序陣列在某個未知軸點旋轉(例如 [0,1,2,4,5,6,7] 變成 [4,5,6,7,0,1,2])。\n給定目標值 target,在 O(log n) 時間內找出其索引,不存在則回傳 -1。\n\n## 面試重點\n此題是**修改版二分搜尋**,測試如何在部分有序的陣列中應用二分搜尋。核心思路:\n1. 旋轉後陣列被分為兩個升序部分\n2. 二分搜尋時,mid 必定落在某一個有序部分\n3. 判斷 target 是否在有序部分的範圍內,決定搜尋方向\n\n判斷邏輯:\n- 若 nums[left] <= nums[mid],左半部有序\n  - 若 target 在 [nums[left], nums[mid]) 範圍,搜尋左半部\n  - 否則搜尋右半部\n- 否則右半部有序\n  - 若 target 在 (nums[mid], nums[right]] 範圍,搜尋右半部\n  - 否則搜尋左半部\n\n面試官會重點觀察:\n- 能否正確判斷哪半部是有序的\n- 邊界情況:nums[left] == nums[mid] 的處理(考慮重複元素)\n- 範圍判斷的嚴謹性:開閉區間的正確使用\n- 能否清楚解釋為何仍是 O(log n):每次排除一半\n\n此題展現了**如何在特殊約束下保持二分搜尋的核心思想**。\n\n## 複雜度\n- 時間複雜度:O(log n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若陣列包含重複元素,最壞時間複雜度如何?\n- 若要找出旋轉軸點的位置,該如何修改?\n- 若不知道陣列是否旋轉,如何判斷?",
      "code": "def search(nums: list[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        \n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1",
      "difficulty": "medium"
    },
    {
      "id": "B13",
      "title": "13. Kth Largest Element in Array",
      "description": "# 13. Kth Largest Element in Array\n\n## 題目\n給定整數陣列 nums 和整數 k,回傳陣列中第 k 大的元素(非第 k 個不同元素)。\n\n## 面試重點\n此題測試**快速選擇(QuickSelect)演算法**與**堆(Heap)的應用**,是理解平均與最壞時間複雜度的典型案例。\n\n**方法一:快速選擇(最優)**\n- 基於快速排序的 partition,但只遞迴一半\n- 平均 O(n),最壞 O(n²)\n- 原地操作,空間 O(1)\n\n**方法二:最小堆(Min Heap)**\n- 維護大小為 k 的最小堆\n- 遍歷陣列,保持堆中是最大的 k 個元素\n- 時間 O(n log k),空間 O(k)\n- 適合 k 很小或資料流場景\n\n**方法三:排序**\n- 直接排序後取第 k 個\n- 時間 O(n log n),最簡單但非最優\n\n面試官會重點觀察:\n- 能否實作快速選擇的 partition 邏輯\n- 理解隨機化 pivot 可降低最壞情況發生機率\n- 堆方法中,為何用最小堆而非最大堆\n- 索引轉換:第 k 大 = 從大到小排序後的索引 k-1 = 從小到大排序後的索引 n-k\n- 不同方法的權衡:時間 vs 空間,平均 vs 最壞\n\n此題展現了**選擇演算法的經典應用**與**不同資料結構的適用場景**。\n\n## 複雜度\n- 快速選擇:時間 O(n) 平均,O(n²) 最壞;空間 O(1)\n- 最小堆:時間 O(n log k);空間 O(k)\n\n## Follow-up\n- 若陣列無法全部載入記憶體,如何找第 k 大元素?\n- 若要找中位數,該用什麼方法?\n- 若是資料流,如何動態維護第 k 大元素?",
      "code": "import random\n\n# Method 1: quick select\ndef find_kth_largest(nums: list[int], k: int) -> int:\n    def partition(left, right, pivot_index):\n        pivot = nums[pivot_index]\n        nums[pivot_index], nums[right] = nums[right], nums[pivot_index]\n        store_index = left\n        \n        for i in range(left, right):\n            if nums[i] < pivot:\n                nums[i], nums[store_index] = nums[store_index], nums[i]\n                store_index += 1\n        \n        nums[store_index], nums[right] = nums[right], nums[store_index]\n        return store_index\n    \n    def select(left, right, k_smallest):\n        if left == right:\n            return nums[left]\n        \n        pivot_index = random.randint(left, right)\n        pivot_index = partition(left, right, pivot_index)\n\n        if k_smallest == pivot_index:\n            return nums[k_smallest]\n        elif k_smallest < pivot_index:\n            return select(left, pivot_index - 1, k_smallest)\n        else:\n            return select(pivot_index + 1, right, k_smallest)\n    \n    return select(0, len(nums) - 1, len(nums) - k)\n\n# Method 2: min heap\nimport heapq\n\ndef find_kth_largest_heap(nums: list[int], k: int) -> int:\n    heap = []\n\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return heap[0]",
      "difficulty": "medium"
    },
    {
      "id": "B14",
      "title": "14. Top K Frequent Elements",
      "description": "\n# 14. Top K Frequent Elements\n\n## 題目\n給定整數陣列 nums 和整數 k,回傳出現頻率前 k 高的元素。答案可以任意順序回傳。\n\n## 面試重點\n此題測試**堆的應用與桶排序**,是頻率統計問題的標準模板。多種解法權衡:\n\n**方法一:最小堆(通用解法)**\n- HashMap 統計頻率\n- 維護大小為 k 的最小堆(以頻率為鍵)\n- 時間 O(n log k),空間 O(n)\n\n**方法二:桶排序(最優)**\n- HashMap 統計頻率\n- 創建 n+1 個桶,桶 i 存放頻率為 i 的元素\n- 從後向前取 k 個元素\n- 時間 O(n),空間 O(n)\n\n**方法三:快速選擇**\n- 統計頻率後,對頻率陣列做快速選擇\n- 平均 O(n),但實作較複雜\n\n面試官會重點觀察:\n- 能否識別這是「Top K」問題,想到堆\n- 桶排序的巧妙運用:頻率範圍有限(1 到 n)\n- 為何桶排序是 O(n):不需要比較排序\n- 堆大小為 k 而非 n 的原因:降低空間複雜度\n- 能否根據 k 的大小選擇合適方法:k 小用堆,k 大用桶\n\n此題展現了**如何根據問題特性選擇最優資料結構**。\n\n## 複雜度\n最小堆:時間 O(n log k);空間 O(n)\n桶排序:時間 O(n);空間 O(n)\n\n## Follow-up\n- 若是資料流,如何動態維護 Top K?\n- 若 k 非常接近 n,哪種方法更優?\n- 若要回傳頻率而非元素,該如何修改?",
      "code": "from collections import Counter\nimport heapq\n\n# Method 1: min heap\ndef top_k_frequent(nums: list[int], k: int) -> list[int]:\n    count = Counter(nums)\n    return heapq.nlargest(k, count.keys(), key=count.get)\n\n# Method 2: bucket sort\ndef top_k_frequent_bucket(nums: list[int], k: int) -> list[int]:\n    count = Counter(nums)\n    n = len(nums)\n    \n    bucket = [[] for _ in range(n + 1)]\n    for num, freq in count.items():\n        bucket[freq].append(num)\n    \n    result = []\n    for freq in range(n, 0, -1):\n        if bucket[freq]:\n            result.extend(bucket[freq])\n            if len(result) >= k:\n                return result[:k]\n    \n    return result",
      "difficulty": "medium"
    },
    {
      "id": "B15",
      "title": "15. Coin Change",
      "description": "\n# 15. Coin Change\n\n## 題目\n給定不同面額的硬幣 coins 和總金額 amount,計算組成該金額所需的最少硬幣數。\n若無法組成,回傳 -1。假設每種硬幣數量無限。\n\n## 面試重點\n此題是**完全背包問題**的經典應用,測試動態規劃的狀態定義與轉移方程設計。\n\n核心思路:\n- 狀態定義:dp[i] = 組成金額 i 所需的最少硬幣數\n- 初始狀態:dp[0] = 0,其餘設為無窮大\n- 狀態轉移:dp[i] = min(dp[i], dp[i - coin] + 1),對所有 coin ≤ i\n- 最終答案:dp[amount],若仍為無窮大則無解\n\n面試官會重點觀察:\n- 能否正確定義狀態與轉移方程\n- 初始值設置:dp[0] = 0 的理解(組成 0 需要 0 個硬幣)\n- 為何是完全背包而非 0-1 背包:硬幣可重複使用\n- 迴圈順序:外層 amount,內層 coins(或反過來都可)\n- 邊界檢查:coin <= i 才更新\n- 空間優化:能否用一維陣列而非二維\n\n此題展現了**DP 狀態設計的一般流程**:定義狀態 → 找轉移 → 確定邊界 → 計算順序。\n\n## 複雜度\n- 時間複雜度:O(amount × len(coins))\n- 空間複雜度:O(amount)\n\n## Follow-up\n- 若要輸出具體的硬幣組合,該如何修改?\n- 若有硬幣數量限制,演算法如何調整?(變成 0-1 背包)\n- 若要計算組成金額的方法數(而非最少硬幣數),該如何修改?",
      "code": "def coin_change(coins: list[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1",
      "difficulty": "medium"
    },
    {
      "id": "B16",
      "title": "16. Longest Increasing Subsequence",
      "description": "# 16. Longest Increasing Subsequence\n\n## 題目\n給定整數陣列 nums,找出最長嚴格遞增子序列的長度。\n子序列不需要連續,但必須保持相對順序。\n\n## 面試重點\n此題有兩種解法,測試**DP 優化與二分搜尋的結合**。\n\n**方法一:動態規劃 O(n²)**\n- 狀態定義:dp[i] = 以 nums[i] 結尾的最長遞增子序列長度\n- 狀態轉移:dp[i] = max(dp[j] + 1),其中 j < i 且 nums[j] < nums[i]\n- 直觀但效率較低\n\n**方法二:DP + 二分搜尋 O(n log n)**\n- 維護陣列 tails,tails[i] = 長度為 i+1 的遞增子序列的最小尾部元素\n- tails 陣列保持有序,用二分搜尋找插入位置\n- 核心思想:貪心地保持每個長度的子序列盡可能小的尾部\n\n面試官會重點觀察:\n- 能否實作基礎的 O(n²) DP\n- 能否理解 O(n log n) 方法的核心思想:\n  - 為何維護「最小尾部元素」\n  - 為何可以用二分搜尋\n  - tails 陣列的語義:不是實際的子序列,而是各長度子序列的最優尾部\n- 二分搜尋的變形:找第一個 >= target 的位置\n- 最終答案是 tails 的長度,而非某個 dp 值\n\n此題展現了**如何通過輔助資料結構與二分搜尋優化 DP**。\n\n## 複雜度\n- DP:時間 O(n²);空間 O(n)\n- DP + 二分:時間 O(n log n);空間 O(n)\n\n## Follow-up\n- 若要輸出最長遞增子序列本身,該如何修改?\n- 若要找最長非嚴格遞增(允許相等),演算法如何調整?\n- 若要找最長遞減子序列,該如何修改?",
      "code": "# Method 1: O(n²) DP\ndef length_of_lis(nums: list[int]) -> int:\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n# Method 2: O(n log n) DP + Binary Search\ndef length_of_lis(nums: list[int]) -> int:\n    tails = []\n    \n    for num in nums:\n        left, right = 0, len(tails)\n        while left < right:\n            mid = left + (right - left) // 2\n            if tails[mid] < num:\n                left = mid + 1\n            else:\n                right = mid\n        \n        if left == len(tails):\n            tails.append(num)\n        else:\n            tails[left] = num\n    \n    return len(tails)",
      "difficulty": "medium"
    },
    {
      "id": "B17",
      "title": "17. Word Break",
      "description": "# 17. Word Break\n\n## 題目\n給定字串 s 和字典 wordDict,判斷 s 是否可以被分割成字典中的單詞序列。\n同一單詞可以重複使用。\n\n## 面試重點\n此題測試**字串 DP 與記憶化搜尋**,核心是子問題的定義與重疊性識別。\n\n**方法一:動態規劃**\n- 狀態定義:dp[i] = 字串 s[0:i] 是否可被分割\n- 狀態轉移:dp[i] = true,若存在 j < i 使得 dp[j] = true 且 s[j:i] 在字典中\n- 時間 O(n² × m),m 為平均單詞長度\n\n**方法二:記憶化 DFS**\n- 遞迴檢查從當前位置開始的子字串\n- 用 memo 記錄已計算的結果\n- 更直觀但可能堆疊溢位\n\n面試官會重點觀察:\n- 能否識別這是 DP 問題:有重疊子問題\n- 狀態定義的清晰度:dp[i] 代表的是前綴而非後綴\n- 雙層迴圈的意義:外層遍歷結束位置,內層尋找分割點\n- 字典查找優化:用 Set 而非 List,O(1) 查找\n- 剪枝:若 s[j:i] 長度超過字典最長單詞,可跳過\n- 邊界:dp[0] = true 的含義(空字串可被分割)\n\n此題展現了**如何將字串問題轉化為 DP**,特別是前綴型 DP。\n\n## 複雜度\n- 時間複雜度:O(n² × m),n 為字串長度,m 為平均單詞長度\n- 空間複雜度:O(n)\n\n## Follow-up\n- 若要回傳所有可能的分割方式,該如何修改?\n- 若字典非常大,如何優化查找?\n- 若要找最少分割次數,演算法如何調整?",
      "code": "def word_break(s: str, word_dict: list[str]) -> bool:\n    word_set = set(word_dict)\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[n]",
      "difficulty": "medium"
    },
    {
      "id": "B18",
      "title": "18. Combination Sum",
      "description": "# 18. Combination Sum\n\n## 題目\n給定無重複元素的陣列 candidates 和目標值 target,找出所有和為 target 的數字組合。\n同一數字可以重複選擇任意次。\n\n## 面試重點\n此題是**回溯法(Backtracking)**的經典應用,測試遞迴樹的剪枝與去重。\n\n核心思路:\n- 遞迴探索所有可能的組合\n- 每次選擇一個數字,遞迴尋找剩餘 target\n- 剪枝:若當前和已超過 target,停止探索\n- 去重:從當前索引開始選擇,避免 [2,3] 和 [3,2] 重複\n\n回溯模板:\n```\ndef backtrack(start, path, remain):\n    if remain == 0:\n        result.append(path[:])  # 找到解\n        return\n    if remain < 0:\n        return  # 剪枝\n    \n    for i in range(start, len(candidates)):\n        path.append(candidates[i])\n        backtrack(i, path, remain - candidates[i])  # i 而非 i+1,可重複\n        path.pop()  # 回溯\n```\n\n面試官會重點觀察:\n- 能否正確實作回溯框架:選擇 → 遞迴 → 撤銷選擇\n- 去重邏輯:start 參數的作用,為何是 i 而非 i+1\n- 剪枝優化:提前終止無效分支\n- path 的複製:append(path[:]) vs append(path)\n- 時間複雜度分析:O(2^n) 的理解(決策樹的分支數)\n\n此題展現了**回溯法的標準模板**,適用於組合、排列、子集等問題。\n\n## 複雜度\n- 時間複雜度:O(2^target),最壞情況\n- 空間複雜度:O(target),遞迴深度\n\n## Follow-up\n- 若陣列包含重複元素,如何去重?\n- 若限制每個數字最多使用 k 次,該如何修改?\n- 若要找組合數而非所有組合,能否用 DP 優化?",
      "code": "def combination_sum(candidates: list[int], target: int) -> list[list[int]]:\n    result = []\n\n    def backtrack(start, path, remain):\n        if remain == 0:\n            result.append(path[:])\n            return\n        if remain < 0:\n            return\n\n        for i in range(start, len(candidates)):\n            path.append(candidates[i])\n            backtrack(i, path, remain - candidates[i])\n            path.pop()\n\n    backtrack(0, [], target)\n    return result",
      "difficulty": "medium"
    },
    {
      "id": "B19",
      "title": "19. Permutations",
      "description": "# 19. Permutations\n\n## 題目\n給定無重複數字的陣列 nums,回傳所有可能的全排列。\n\n## 面試重點\n此題測試**回溯法的排列變形**,與組合問題的關鍵差異是**順序敏感**。\n\n核心差異:\n- 組合:[1,2] 和 [2,1] 視為相同,用 start 參數避免重複\n- 排列:[1,2] 和 [2,1] 視為不同,需要 used 陣列標記已使用元素\n\n回溯模板:\n```\ndef backtrack(path):\n    if len(path) == n:\n        result.append(path[:])\n        return\n    \n    for i in range(n):\n        if used[i]:\n            continue  # 已使用,跳過\n        \n        used[i] = True\n        path.append(nums[i])\n        backtrack(path)\n        path.pop()\n        used[i] = False\n```\n\n面試官會重點觀察:\n- 能否區分排列與組合問題\n- used 陣列的作用:防止同一元素在一個排列中重複使用\n- 為何不用 start 參數:排列需要回頭選擇\n- 終止條件:len(path) == n\n- 空間優化:能否用 path 的 Set 檢查替代 used 陣列\n- 若陣列有重複元素,去重策略(排序 + 剪枝)\n\n此題展現了**排列問題的標準回溯模板**,是理解回溯法的關鍵題目。\n\n## 複雜度\n- 時間複雜度:O(n × n!),n! 個排列,每個複製需要 O(n)\n- 空間複雜度:O(n),遞迴深度\n\n## Follow-up\n- 若陣列包含重複元素,如何去重?\n- 若要找下一個排列(字典序),該用什麼演算法?\n- 若限制只能生成 k 個元素的排列,該如何修改?",
      "code": "def permute(nums: list[int]) -> list[list[int]]:\n    result = []\n    n = len(nums)\n    used = [False] * n\n\n    def backtrack(path):\n        if len(path) == n:\n            result.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            \n            used[i] = True\n            path.append(nums[i])\n            backtrack(path)\n            path.pop()\n            used[i] = False\n\n    backtrack([])\n    return result",
      "difficulty": "medium"
    },
    {
      "id": "B20",
      "title": "20. Generate Parentheses",
      "description": "# 20. Generate Parentheses\n\n## 題目\n給定 n,生成所有由 n 對括號組成的有效組合。\n\n## 面試重點\n此題測試**回溯法的約束條件設計**,展現如何在生成過程中剪枝無效解。\n\n核心約束:\n1. 左括號數量不能超過 n\n2. 右括號數量不能超過左括號數量(保證有效性)\n3. 當左右括號都用完 n 個時,得到一個有效組合\n\n回溯策略:\n- 每次有兩個選擇:加左括號或加右括號\n- 加左括號的條件:left < n\n- 加右括號的條件:right < left\n- 終止條件:left == right == n\n\n面試官會重點觀察:\n- 能否識別這是受約束的生成問題\n- 約束條件的正確性:為何 right < left 保證有效性\n- 剪枝的效果:避免生成無效組合後再驗證\n- 能否清楚解釋決策樹:每個節點有 0-2 個分支\n- 時間複雜度:卡塔蘭數 C(n) ≈ 4^n / (n√n)\n\n此題展現了**如何在回溯過程中利用約束剪枝**,比生成後驗證更高效。\n\n## 複雜度\n- 時間複雜度:O(4^n / √n),卡塔蘭數\n- 空間複雜度:O(n),遞迴深度\n\n## Follow-up\n- 若要生成長度為 2n 的所有括號序列(包含無效的),數量為多少?\n- 若有多種括號類型(如()、[]、{}),該如何修改?\n- 能否用迭代方式生成?",
      "code": "def generate_parenthesis(n: int) -> list[str]:\n    result = []\n\n    def backtrack(path, left, right):\n        if len(path) == 2 * n:\n            result.append(path)\n            return\n\n        if left < n:\n            backtrack(path + '(', left + 1, right)\n\n        if right < left:\n            backtrack(path + ')', left, right + 1)\n\n    backtrack('', 0, 0)\n    return result",
      "difficulty": "medium"
    }
  ],
  "hard": [
    {
      "id": "C1",
      "title": "1. Edit Distance",
      "description": "# 1. Edit Distance\n\n## 題目\n給定兩個字串 word1 和 word2,計算將 word1 轉換成 word2 所需的最少操作次數。\n允許的操作:插入字元、刪除字元、替換字元。\n\n## 面試重點\n此題是**經典二維 DP 問題**,測試對編輯距離(Levenshtein Distance)的理解,是自然語言處理與字串相似度的基礎演算法。\n\n核心思路:\n- 狀態定義:dp[i][j] = word1[0:i] 轉換為 word2[0:j] 的最少操作數\n- 狀態轉移:\n  - 若 word1[i-1] == word2[j-1]:dp[i][j] = dp[i-1][j-1]\n  - 否則:dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    - dp[i-1][j] + 1:刪除 word1[i-1]\n    - dp[i][j-1] + 1:插入 word2[j-1]\n    - dp[i-1][j-1] + 1:替換 word1[i-1] 為 word2[j-1]\n- 初始化:dp[0][j] = j, dp[i][0] = i\n\n面試官會重點觀察:\n- 能否正確畫出 DP 表格並理解每個格子的含義\n- 三種操作如何對應到 DP 轉移\n- 邊界初始化的理解:空字串到任意字串需要全部插入/刪除\n- 空間優化:能否用滾動陣列降至 O(min(m,n))\n- 實際應用理解:拼寫檢查、DNA 序列比對、版本控制 diff\n\n**常考公司**:\n- Google(搜尋糾錯、自然語言處理)\n- Microsoft(Office 拼寫檢查)\n- AI Startups(NLP 相關)\n- 生物科技公司(基因序列比對)\n\n此題是**字串 DP 的巔峰之作**,理解它能掌握大部分二維 DP 問題。\n\n## 複雜度\n- 時間複雜度:O(m × n)\n- 空間複雜度:O(m × n),可優化至 O(min(m, n))\n\n## Follow-up\n- 若只允許插入和刪除,演算法如何簡化?\n- 若不同操作有不同代價(加權編輯距離),如何修改?\n- 若要輸出具體的操作序列,該如何回溯?\n- 若字串非常長,如何做記憶體優化?",
      "code": "def min_distance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],\n                    dp[i][j - 1],\n                    dp[i - 1][j - 1]\n                )\n    \n    return dp[m][n]\n\ndef min_distance_optimized(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n\n    if m < n:\n        word1, word2 = word2, word1\n        m, n = n, m\n    \n    prev = list(range(n + 1))\n\n    for i in range(1, m + 1):\n        curr = [i] + [0] * n\n\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                curr[j] = prev[j - 1]\n            else:\n                curr[j] = 1 + min(prev[j], curr[j - 1], prev[j - 1])\n        \n        prev = curr\n    \n    return prev[n]",
      "difficulty": "hard"
    },
    {
      "id": "C2",
      "title": "2. Longest Valid Parentheses",
      "description": "# 2. Longest Valid Parentheses\n\n## 題目\n給定只包含 '(' 和 ')' 的字串,找出最長有效(格式正確且連續)括號子字串的長度。\n\n## 面試重點\n此題測試**Stack 與 DP 的多種解法**,展現同一問題的不同思維角度。\n\n**方法一:動態規劃**\n- 狀態定義:dp[i] = 以 i 結尾的最長有效括號長度\n- 狀態轉移:\n  - s[i] == '(':dp[i] = 0(不可能以左括號結尾)\n  - s[i] == ')':\n    - 若 s[i-1] == '(':dp[i] = dp[i-2] + 2\n    - 若 s[i-1] == ')' 且 s[i-dp[i-1]-1] == '(':\n      dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\n\n**方法二:Stack**\n- 維護左括號的索引\n- 遇到右括號時配對,計算長度\n- 用 -1 作為基準索引\n\n**方法三:雙向掃描**\n- 從左到右:記錄左右括號數,相等時更新最大值,右>左時重置\n- 從右到左:記錄左右括號數,相等時更新最大值,左>右時重置\n- 處理只有左括號過多或右括號過多的情況\n\n面試官會重點觀察:\n- 能否實作至少兩種方法\n- DP 方法中複雜轉移方程的理解\n- Stack 方法中基準索引的巧妙運用\n- 雙向掃描方法的簡潔性與正確性證明\n- 各方法的時間空間權衡\n\n**常考公司**:\n- Google(考察多種解法能力)\n- Facebook/Meta(括號相關變形題常客)\n- Amazon(編碼面試高頻)\n\n此題展現了**一題多解的思維廣度**,是展現演算法功底的好題。\n\n## 複雜度\n**DP 方法**:\n- 時間複雜度:O(n)\n- 空間複雜度:O(n)\n\n**Stack 方法**:\n- 時間複雜度:O(n)\n- 空間複雜度:O(n)\n\n**雙向掃描**:\n- 時間複雜度:O(n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若要找出所有最長有效括號子字串的起始位置,如何修改?\n- 若括號類型增加(如 []、{}),演算法如何調整?\n- 若要求不連續的最長有效括號,該用什麼方法?",
      "code": "# Method 1: Dynamic Programming\ndef longest_valid_parentheses_dp(s: str) -> int:\n    n = len(s)\n    if n < 2:\n        return 0\n    \n    dp = [0] * n\n    max_len = 0\n\n    for i in range(1, n):\n        if s[i] == ')':\n            if s[i - 1] == '(':\n                dp[i] = (dp[i - 2] if i >= 2 else 0) + 2\n            elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':\n                dp[i] = dp[i - 1] + 2 + (dp[i - dp[i - 1] - 2] if i - dp[i - 1] >= 2 else 0)\n\n            max_len = max(max_len, dp[i])\n    \n    return max_len\n\n# Method 2: Stack\ndef longest_valid_parentheses_stack(s: str) -> int:\n    stack = [-1]\n    max_len = 0\n\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if not stack:\n                stack.append(i)\n            else:\n                max_len = max(max_len, i - stack[-1])\n    \n    return max_len\n\n# Method 3: Two-way Scan\ndef longest_valid_parentheses_scan(s: str) -> int:\n    left = right = max_len = 0\n\n    for char in s:\n        if char == '(':\n            left += 1\n        else:\n            right += 1\n        \n        if left == right:\n            max_len = max(max_len, 2 * right)\n        elif right > left:\n            left = right = 0\n    \n    left = right = 0\n\n    for char in reversed(s):\n        if char == '(':\n            left += 1\n        else:\n            right += 1\n        \n        if left == right:\n            max_len = max(max_len, 2 * left)\n        elif left > right:\n            left = right = 0\n    \n    return max_len",
      "difficulty": "hard"
    },
    {
      "id": "C3",
      "title": "3. Regular Expression Matching",
      "description": "# 3. Regular Expression Matching\n\n## 題目\n實作正則表達式匹配,支援 '.'(匹配任意單一字元)和 '*'(匹配零個或多個前面的元素)。\n\n## 面試重點\n此題是**複雜 DP 問題**,測試對狀態空間建模與邊界條件處理的深度理解。\n\n核心思路:\n- 狀態定義:dp[i][j] = s[0:i] 是否匹配 p[0:j]\n- 狀態轉移:\n  - 若 p[j-1] != '*':\n    - 若 s[i-1] == p[j-1] 或 p[j-1] == '.':dp[i][j] = dp[i-1][j-1]\n  - 若 p[j-1] == '*':\n    - 匹配 0 次:dp[i][j] = dp[i][j-2]\n    - 匹配 1+ 次:若 s[i-1] == p[j-2] 或 p[j-2] == '.':dp[i][j] = dp[i-1][j]\n\n面試官會重點觀察:\n- 能否正確處理 '*' 的兩種情況:匹配 0 次和多次\n- 邊界初始化:dp[0][0] = true,以及 p 開頭為 a* 類型的處理\n- 索引對應關係:dp 陣列與字串索引的錯位\n- '*' 與前一個字元的綁定關係理解\n- 能否解釋為何是 dp[i-1][j] 而非 dp[i-1][j-2]\n- 遞迴解法與 DP 解法的對應關係\n\n**常考公司**:\n- Google(系統設計時可能涉及搜尋引擎)\n- Microsoft(文字處理相關產品)\n- 編譯器/解析器相關公司\n- 高頻面試題,考察 DP 功底\n\n此題是**字串 DP 的終極挑戰**,涉及多重條件判斷與狀態轉移。\n\n## 複雜度\n- 時間複雜度:O(m × n)\n- 空間複雜度:O(m × n),可優化至 O(n)\n\n## Follow-up\n- 若支援 '+'(匹配一個或多個),該如何修改?\n- 若支援 '?'(匹配零個或一個),演算法如何調整?\n- 能否用有限狀態機(FSM)實現?\n- 若要支援完整的正則表達式(如 []、|),該如何設計?",
      "code": "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n    dp[0][0] = True\n\n    for j in range(2, n + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 2]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2]\n\n                if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                    dp[i][j] = dp[i][j] or dp[i - 1][j]\n            else:\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n    \n    return dp[m][n]",
      "difficulty": "hard"
    },
    {
      "id": "C4",
      "title": "4. Best Time to Buy and Sell Stock III",
      "description": "# 4. Best Time to Buy and Sell Stock III\n\n## 題目\n給定股票價格陣列,最多完成兩筆交易,計算最大利潤。\n注意:不能同時持有多筆交易(必須先賣出才能再買入)。\n\n## 面試重點\n此題是**狀態機 DP 的經典應用**,測試對多階段決策問題的建模能力。\n\n核心思路:\n- 定義四個狀態:\n  - buy1:第一次買入後的最大利潤\n  - sell1:第一次賣出後的最大利潤\n  - buy2:第二次買入後的最大利潤\n  - sell2:第二次賣出後的最大利潤\n- 狀態轉移:\n  - buy1 = max(buy1, -price)\n  - sell1 = max(sell1, buy1 + price)\n  - buy2 = max(buy2, sell1 - price)\n  - sell2 = max(sell2, buy2 + price)\n\n面試官會重點觀察:\n- 能否畫出狀態轉移圖:未持有 ↔ 持有第一筆 ↔ 已售出第一筆 ↔ 持有第二筆 ↔ 已售出第二筆\n- 初始值設定:buy1 = buy2 = -∞(或 -prices[0]),sell1 = sell2 = 0\n- 為何用負數表示買入:因為買入是支出\n- 能否推廣到 k 筆交易的通用解法\n- 空間優化:只需 4 個變數,不需陣列\n\n**常考公司**:\n- Citadel、Jane Street(量化交易公司高頻)\n- Two Sigma、DE Shaw(金融科技)\n- 對沖基金面試常見\n- Google、Amazon 也會考\n\n此題是**股票問題系列的進階版**,理解它能掌握所有股票交易 DP。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若允許 k 筆交易,演算法如何推廣?\n- 若有交易手續費,狀態轉移如何調整?\n- 若有冷卻期(賣出後需等待一天才能再買),該如何修改?\n- 若 k 非常大(k >= n/2),能否簡化為無限交易?",
      "code": "def max_profit(prices: list[int]) -> int:\n    if not prices:\n        return 0\n    \n    buy1 = buy2 = float('-inf')\n    sell1 = sell2 = 0\n\n    for price in prices:\n        buy1 = max(buy1, -price)\n        sell1 = max(sell1, buy1 + price)\n        buy2 = max(buy2, sell1 - price)\n        sell2 = max(sell2, buy2 + price)\n    \n    return sell2",
      "difficulty": "hard"
    },
    {
      "id": "C5",
      "title": "5. Serialize and Deserialize Binary Tree",
      "description": "# 5. Serialize and Deserialize Binary Tree\n\n## 題目\n設計演算法將二元樹序列化為字串,並能從字串反序列化回二元樹。\n序列化格式可自行定義。\n\n## 面試重點\n此題測試**樹的遍歷與編碼設計**,是系統設計與資料持久化的基礎。\n\n核心思路:\n**方法一:前序遍歷(DFS)**\n- 序列化:前序遍歷,空節點用特殊符號(如 'null')\n- 反序列化:依序讀取,遞迴重建\n- 優點:簡潔,易於實作\n\n**方法二:層序遍歷(BFS)**\n- 序列化:層序遍歷,記錄所有節點(包括 null)\n- 反序列化:用佇列重建\n- 優點:直觀,與樹的視覺表示一致\n\n面試官會重點觀察:\n- 能否設計簡潔且無歧義的編碼格式\n- 為何需要記錄空節點:區分左右子樹\n- 序列化與反序列化的對稱性\n- 邊界處理:空樹、只有根節點、斜樹\n- 分隔符的選擇:逗號、空格等\n- 能否處理節點值包含分隔符的情況\n\n**常考公司**:\n- Google(分散式系統數據序列化)\n- Amazon(資料持久化)\n- Database 公司(儲存引擎設計)\n- 系統設計常見子問題\n\n此題展現了**資料結構與字串編碼的結合**,是實際工程中的常見需求。\n\n## 複雜度\n**前序遍歷**:\n- 時間複雜度:O(n)\n- 空間複雜度:O(n)\n\n**層序遍歷**:\n- 時間複雜度:O(n)\n- 空間複雜度:O(n)\n\n## Follow-up\n- 若要最小化序列化後的字串長度,該如何優化?\n- 若二元樹是 BST,能否利用其性質減少編碼長度?\n- 若要支援流式反序列化(邊接收邊重建),該如何設計?\n- 若節點值可能包含特殊字元,如何處理?",
      "code": "# Method 1: Preorder DFS\nclass Codec:\n    def serialize(self, root):\n        def dfs(node):\n            if not node:\n                return 'null'\n            return str(node.val) + ',' + dfs(node.left) + ',' + dfs(node.right)\n        \n        return dfs(root)\n    \n    def deserialize(self, data):\n        def dfs(nodes):\n            val = next(nodes)\n            if val == 'null':\n                return None\n            \n            node = TreeNode(int(val))\n            node.left = dfs(nodes)\n            node.right = dfs(nodes)\n            return node\n        \n        return dfs(iter(data.split(',')))\n\n# Method 2: Level-order BFS\nclass CodecBFS:\n    def serialize(self, root):\n        if not root:\n            return ''\n        \n        result = []\n        queue = [root]\n\n        while queue:\n            node = queue.pop(0)\n            if node:\n                result.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append('null')\n        \n        return ','.join(result)\n    \n    def deserialize(self, data):\n        if not data:\n            return None\n        \n        nodes = data.split(',')\n        root = TreeNode(int(nodes[0]))\n        queue = [root]\n        i = 1\n\n        while queue:\n            node = queue.pop(0)\n\n            if nodes[i] != 'null':\n                node.left = TreeNode(int(nodes[i]))\n                queue.append(node.left)\n            i += 1\n\n            if nodes[i] != 'null':\n                node.right = TreeNode(int(nodes[i]))\n                queue.append(node.right)\n            i += 1\n        \n        return root",
      "difficulty": "hard"
    },
    {
      "id": "C6",
      "title": "6. Binary Tree Maximum Path Sum",
      "description": "# 6. Binary Tree Maximum Path Sum\n\n## 題目\n給定二元樹,找出任意節點到任意節點的路徑中,節點值總和的最大值。\n路徑定義:從任一節點出發,沿父子關係到達另一節點的路徑,每個節點最多經過一次。\n\n## 面試重點\n此題測試**後序遍歷與全域最優解的維護**,核心難點是區分「路徑和」與「可向上貢獻的和」。\n\n核心思路:\n- 遞迴函數回傳:經過當前節點向上延伸的最大單邊和\n- 內部計算:經過當前節點的完整路徑最大和(可能包含左右子樹)\n- 更新全域最大值:max_sum = max(max_sum, node.val + left_gain + right_gain)\n- 回傳給父節點:node.val + max(left_gain, right_gain, 0)\n\n關鍵洞察:\n1. 每個節點可以選擇:只取自己、取自己+左子樹、取自己+右子樹\n2. 路徑不能分叉(不能同時向左右延伸後再向上)\n3. 負數子樹直接捨棄(max with 0)\n\n面試官會重點觀察:\n- 能否區分「內部最大路徑和」與「向上貢獻的和」\n- 為何不能直接回傳最大路徑和:會導致分叉路徑\n- 後序遍歷的必要性:需要先知道子樹資訊\n- 全域變數的使用:因為遞迴回傳值有特殊意義\n- 負數處理:max(gain, 0)的作用\n\n**常考公司**:\n- Google(高頻樹題)\n- Facebook/Meta(樹的變形題常客)\n- Microsoft、Apple\n- 難度較高,展現遞迴理解深度\n\n此題展現了**遞迴回傳值設計的精妙之處**,是樹問題的高階技巧。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(h),遞迴堆疊深度\n\n## Follow-up\n- 若要輸出最大路徑本身(節點序列),該如何修改?\n- 若限制路徑必須從根節點出發,演算法如何簡化?\n- 若是 N 叉樹,演算法如何調整?\n- 若允許經過節點多次,問題會變成什麼?",
      "code": "class Solution:\n    def max_path_sum(self, root: TreeNode) -> int:\n        self.max_sum = float('-inf')\n\n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n\n            current_path_sum = node.val + left_gain + right_gain\n            self.max_sum = max(self.max_sum, current_path_sum)\n\n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return self.max_sum",
      "difficulty": "hard"
    },
    {
      "id": "C7",
      "title": "7. Word Ladder II",
      "description": "# 7. Word Ladder II\n\n## 題目\n給定起始單詞 beginWord、結束單詞 endWord 和字典 wordList,找出所有從 beginWord 到 endWord 的最短轉換序列。\n每次只能改變一個字母,且轉換過程中的單詞必須在字典中。\n\n## 面試重點\n此題測試**BFS 找最短路徑 + DFS 回溯生成所有路徑**,是圖論與回溯的綜合應用。\n\n核心思路:\n1. **BFS 建圖**:找出每個單詞的最短距離與所有可達的下一層單詞\n2. **DFS 回溯**:從 endWord 反向回溯到 beginWord,生成所有最短路徑\n3. 關鍵資料結構:\n   - distance:記錄每個單詞到 beginWord 的最短距離\n   - neighbors:記錄每個單詞可以到達的下一層單詞\n\n面試官會重點觀察:\n- 能否意識到需要先 BFS 後 DFS\n- BFS 時如何記錄分層資訊:距離相同的為同一層\n- 為何要記錄 neighbors 而非完整圖:避免回溯時走回頭路\n- 單詞變換的實作:26 個字母逐一嘗試\n- 優化:雙向 BFS 可大幅減少搜尋空間\n- 記憶體優化:大字典時的處理策略\n\n**常考公司**:\n- Google(高頻圖論題)\n- Amazon(BFS/DFS 綜合考察)\n- LinkedIn(社交網路相關)\n- 難度極高,通常作為壓軸題\n\n此題展現了**BFS 與 DFS 的完美結合**,以及如何在圖中找所有最短路徑。\n\n## 複雜度\n- 時間複雜度:O(N × L² + α),N 為字典大小,L 為單詞長度,α 為答案數量\n- 空間複雜度:O(N × L)\n\n## Follow-up\n- 若只要一條最短路徑,如何優化?\n- 若字典非常大,如何優化單詞變換的查找?\n- 能否用 A* 演算法優化?\n- 若允許刪除/添加字母,演算法如何調整?",
      "code": "from collections import defaultdict, deque\n\ndef find_ladders(begin_word: str, end_word: str, word_list: list[str]) -> list[list[str]]:\n    word_set = set(word_list)\n    if end_word not in word_set:\n        return []\n    \n    neighbors = defaultdict(list)\n    distance = {begin_word: 0}\n    \n    def bfs():\n        queue = deque([begin_word])\n        found = False\n        \n        while queue and not found:\n            level_size = len(queue)\n            visited_this_level = set()\n            \n            for _ in range(level_size):\n                word = queue.popleft()\n                current_dist = distance[word]\n                \n                for i in range(len(word)):\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\n                        if c == word[i]:\n                            continue\n                        \n                        next_word = word[:i] + c + word[i+1:]\n                        \n                        if next_word == end_word:\n                            found = True\n                        \n                        if next_word not in word_set:\n                            continue\n                        \n                        if next_word not in distance:\n                            distance[next_word] = current_dist + 1\n                            visited_this_level.add(next_word)\n                            neighbors[word].append(next_word)\n                        elif distance[next_word] == current_dist + 1:\n                            neighbors[word].append(next_word)\n            \n            for word in visited_this_level:\n                queue.append(word)\n    \n    bfs()\n    \n    if end_word not in distance:\n        return []\n    \n    result = []\n    path = [begin_word]\n    \n    def dfs(word):\n        if word == end_word:\n            result.append(path[:])\n            return\n        \n        for next_word in neighbors[word]:\n            path.append(next_word)\n            dfs(next_word)\n            path.pop()\n    \n    dfs(begin_word)\n    return result",
      "difficulty": "hard"
    },
    {
      "id": "C8",
      "title": "8. Median of Two Sorted Arrays",
      "description": "# 8. Median of Two Sorted Arrays\n\n## 題目\n給定兩個已排序陣列 nums1 和 nums2,找出這兩個陣列合併後的中位數。\n要求時間複雜度為 O(log(m+n))。\n\n## 面試重點\n此題是**二分搜尋的終極挑戰**,測試對「在兩個陣列中找第 k 小元素」的深度理解。\n\n核心思路:\n**方法一:二分搜尋劃分點**\n- 在較短陣列中二分搜尋劃分點\n- 使得左半部元素數 = 右半部元素數(或相差 1)\n- 確保 max(左半部) ≤ min(右半部)\n- 中位數 = (max(左半部) + min(右半部)) / 2\n\n**方法二:遞迴找第 k 小**\n- 每次排除 k/2 個元素\n- 比較兩陣列的第 k/2 個元素,較小的那側前 k/2 個元素可排除\n- 遞迴直到 k=1 或某陣列為空\n\n面試官會重點觀察:\n- 能否理解為何需要在較短陣列中搜尋:減少搜尋空間\n- 劃分點的正確計算:處理奇偶長度\n- 邊界條件:陣列為空、劃分點在邊界\n- 為何是 O(log(min(m,n))):二分搜尋較短陣列\n- 能否處理重複元素\n- 第 k 小方法的遞迴終止條件\n\n**常考公司**:\n- Google(演算法深度考察)\n- Facebook/Meta(Hard 題常客)\n- Microsoft、Amazon\n- 頂尖公司的 onsite 壓軸題\n- Quant 公司常考\n\n此題是**二分搜尋的巔峰應用**,需要對二分搜尋有極深理解。\n\n## 複雜度\n- 時間複雜度:O(log(min(m, n)))\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若要找第 k 小的元素,演算法如何推廣?\n- 若是三個已排序陣列,時間複雜度能否維持對數級?\n- 若陣列未排序,該用什麼方法?\n- 若需要支援動態插入,如何維護中位數?",
      "code": "# Method 1: Binary Search on Partition\ndef find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    \n    while left <= right:\n        partition1 = (left + right) // 2\n        partition2 = (m + n + 1) // 2 - partition1\n        \n        max_left1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]\n        min_right1 = float('inf') if partition1 == m else nums1[partition1]\n        \n        max_left2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]\n        min_right2 = float('inf') if partition2 == n else nums2[partition2]\n        \n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            if (m + n) % 2 == 0:\n                return (max(max_left1, max_left2) + min(min_right1, min_right2)) / 2\n            else:\n                return max(max_left1, max_left2)\n        elif max_left1 > min_right2:\n            right = partition1 - 1\n        else:\n            left = partition1 + 1\n    \n    return 0.0\n\n# Method 2: Find k-th Element\ndef find_median_sorted_arrays_kth(nums1: list[int], nums2: list[int]) -> float:\n    def find_kth(k):\n        i1, i2 = 0, 0\n        \n        while True:\n            if i1 == len(nums1):\n                return nums2[i2 + k - 1]\n            if i2 == len(nums2):\n                return nums1[i1 + k - 1]\n            if k == 1:\n                return min(nums1[i1], nums2[i2])\n            \n            mid1 = min(i1 + k // 2 - 1, len(nums1) - 1)\n            mid2 = min(i2 + k // 2 - 1, len(nums2) - 1)\n            \n            if nums1[mid1] <= nums2[mid2]:\n                k -= mid1 - i1 + 1\n                i1 = mid1 + 1\n            else:\n                k -= mid2 - i2 + 1\n                i2 = mid2 + 1\n    \n    total = len(nums1) + len(nums2)\n    if total % 2 == 1:\n        return find_kth(total // 2 + 1)\n    else:\n        return (find_kth(total // 2) + find_kth(total // 2 + 1)) / 2",
      "difficulty": "hard"
    },
    {
      "id": "C9",
      "title": "9. Merge K Sorted Lists",
      "description": "# 9. Merge K Sorted Lists\n\n## 題目\n給定 k 個已排序的鏈結串列陣列,將它們合併成一個已排序的鏈結串列。\n\n## 面試重點\n此題測試**堆(Heap)的應用與分治思想**,是多路歸併的經典問題。\n\n核心思路:\n**方法一:最小堆**\n- 將每個串列的頭節點放入最小堆\n- 每次取出最小節點,將其 next 放入堆\n- 時間 O(N log k),N 為總節點數\n\n**方法二:分治合併**\n- 兩兩合併串列,類似歸併排序\n- 第一輪:k 個串列合併成 k/2 個\n- 持續合併直到剩一個\n- 時間 O(N log k)\n\n**方法三:逐一合併**\n- 依序合併每個串列\n- 時間 O(N × k),較慢\n\n面試官會重點觀察:\n- 能否快速想到堆方法:k 路歸併的標準解法\n- Python heapq 的使用:需要自定義比較或用 (val, node) 元組\n- 分治方法的實作:類似歸併排序的樹狀合併\n- 空間複雜度分析:堆方法 O(k),分治方法 O(log k)遞迴深度\n- 優化:能否避免空串列進堆\n\n**常考公司**:\n- Google(高頻題)\n- Amazon(merge 相關常客)\n- Microsoft、LinkedIn\n- 系統設計中的多路歸併場景\n- 資料庫公司(外部排序)\n\n此題展現了**堆在多路選擇中的威力**,是理解優先佇列應用的關鍵。\n\n## 複雜度\n**最小堆方法**:\n- 時間複雜度:O(N log k)\n- 空間複雜度:O(k)\n\n**分治方法**:\n- 時間複雜度:O(N log k)\n- 空間複雜度:O(log k)\n\n## Follow-up\n- 若 k 非常大,無法全部載入記憶體,如何處理?\n- 若要找第 n 小的元素而非全部合併,如何優化?\n- 若串列不是鏈結串列而是陣列,方法有何不同?\n- 在外部排序中,如何應用這個演算法?",
      "code": "import heapq\n\n# Method 1: Min Heap\ndef merge_k_lists_heap(lists: list[ListNode]) -> ListNode:\n    heap = []\n    \n    for i, node in enumerate(lists):\n        if node:\n            heapq.heappush(heap, (node.val, i, node))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next\n\n# Method 2: Divide and Conquer\ndef merge_k_lists_divide(lists: list[ListNode]) -> ListNode:\n    if not lists:\n        return None\n    if len(lists) == 1:\n        return lists[0]\n    \n    def merge_two(l1, l2):\n        dummy = ListNode(0)\n        current = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                current.next = l1\n                l1 = l1.next\n            else:\n                current.next = l2\n                l2 = l2.next\n            current = current.next\n        \n        current.next = l1 if l1 else l2\n        return dummy.next\n    \n    while len(lists) > 1:\n        merged = []\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 < len(lists) else None\n            merged.append(merge_two(l1, l2))\n        lists = merged\n    \n    return lists[0]",
      "difficulty": "hard"
    },
    {
      "id": "C10",
      "title": "10. Sliding Window Maximum",
      "description": "# 10. Sliding Window Maximum\n\n## 題目\n給定整數陣列 nums 和滑動窗口大小 k,回傳每個窗口位置的最大值。\n\n## 面試重點\n此題測試**單調佇列(Monotonic Queue)**的應用,是資料結構設計的經典題。\n\n核心思路:\n- 維護一個雙端佇列(deque),存儲索引\n- 佇列保持遞減順序:front 是當前窗口最大值的索引\n- 加入新元素時:\n  1. 移除超出窗口範圍的元素\n  2. 從後面移除所有小於當前元素的元素\n  3. 加入當前元素\n- 佇列首元素即為窗口最大值\n\n關鍵洞察:\n- 若 nums[i] ≥ nums[j] 且 i > j,則 nums[j] 永遠不可能是答案\n- 單調性保證每個元素最多進出佇列各一次,amortized O(1)\n\n面試官會重點觀察:\n- 能否識別這不是簡單的堆問題:堆無法 O(log n) 刪除任意元素\n- 單調佇列的維護邏輯:為何從後面刪除\n- 為何儲存索引而非值:需要判斷是否在窗口內\n- deque 的使用:Python collections.deque\n- 邊界處理:前 k-1 個元素不輸出\n\n**常考公司**:\n- Google(單調棧/佇列系列)\n- Bloomberg、Citadel(金融數據處理)\n- 時序數據處理相關公司\n- 需要即時計算統計量的場景\n\n此題展現了**單調資料結構的威力**,是滑動窗口問題的進階技巧。\n\n## 複雜度\n- 時間複雜度:O(n)\n- 空間複雜度:O(k)\n\n## Follow-up\n- 若要找滑動窗口的中位數,該用什麼資料結構?\n- 若要同時維護最大值和最小值,如何優化?\n- 若 k 非常大,接近 n,有更好的方法嗎?\n- 若要找第 k 大而非最大值,演算法如何調整?",
      "code": "from collections import deque\n\ndef max_sliding_window(nums: list[int], k: int) -> list[int]:\n    if not nums or k == 0:\n        return []\n    \n    dq = deque()\n    result = []\n    \n    for i, num in enumerate(nums):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n        \n        while dq and nums[dq[-1]] < num:\n            dq.pop()\n        \n        dq.append(i)\n        \n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result",
      "difficulty": "hard"
    },
    {
      "id": "C11",
      "title": "11. LFU Cache",
      "description": "# 11. LFU Cache\n\n## 題目\n設計一個 LFU(Least Frequently Used)快取,支援 get 和 put 操作,兩者都需在 O(1) 時間完成。\n容量固定,達到容量時移除使用頻率最低的項目,若頻率相同則移除最久未使用的。\n\n## 面試重點\n此題是**多層資料結構設計**的巔峰,測試複雜系統的建模與維護能力。\n\n核心設計:\n1. **key_map**:key → Node,存儲 key 到節點的映射\n2. **freq_map**:frequency → DoublyLinkedList,存儲每個頻率的所有節點\n3. **min_freq**:當前最小頻率,用於淘汰\n\n關鍵操作:\n- **get**:頻率 +1,移動節點到新頻率鏈表\n- **put**:\n  - 若 key 存在:更新值,頻率 +1\n  - 若 key 不存在:\n    - 容量滿:刪除 min_freq 鏈表的尾節點\n    - 插入新節點到頻率 1 的鏈表\n    - 更新 min_freq = 1\n\n面試官會重點觀察:\n- 能否設計出正確的資料結構組合\n- min_freq 的維護:何時更新為 1,何時 +1\n- 頻率變化時的鏈表操作:從舊頻率移除,加入新頻率\n- 雙向鏈表的作用:O(1) 刪除節點\n- 空鏈表的處理:刪除空的頻率鏈表\n- 與 LRU 的對比:LFU 更複雜,需要多一層頻率索引\n\n**常考公司**:\n- Google(系統設計高頻)\n- Facebook/Meta(cache 相關)\n- Amazon、Microsoft\n- CDN 公司、快取服務公司\n- 比 LRU 更難,展現設計能力\n\n此題展現了**如何通過組合多個資料結構達成複雜需求**,是系統設計的微縮版。\n\n## 複雜度\n- 時間複雜度:get 和 put 都是 O(1)\n- 空間複雜度:O(capacity)\n\n## Follow-up\n- 若要支援批次操作,如何優化?\n- 若容量非常大,分散式環境如何實作?\n- 若要支援過期時間(TTL),資料結構如何調整?\n- 與 LRU 相比,LFU 的優缺點是什麼?",
      "code": "class Node:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.freq = 1\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n    \n    def add_node(self, node):\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n        self.size += 1\n    \n    def remove_node(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        self.size -= 1\n    \n    def remove_tail(self):\n        if self.size == 0:\n            return None\n        node = self.tail.prev\n        self.remove_node(node)\n        return node\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.key_map = {}\n        self.freq_map = {}\n        self.min_freq = 0\n    \n    def get(self, key: int) -> int:\n        if key not in self.key_map:\n            return -1\n        \n        node = self.key_map[key]\n        self._update_freq(node)\n        return node.val\n    \n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        \n        if key in self.key_map:\n            node = self.key_map[key]\n            node.val = value\n            self._update_freq(node)\n        else:\n            if len(self.key_map) >= self.capacity:\n                min_freq_list = self.freq_map[self.min_freq]\n                removed_node = min_freq_list.remove_tail()\n                del self.key_map[removed_node.key]\n            \n            new_node = Node(key, value)\n            self.key_map[key] = new_node\n            \n            if 1 not in self.freq_map:\n                self.freq_map[1] = DoublyLinkedList()\n            self.freq_map[1].add_node(new_node)\n            self.min_freq = 1\n    \n    def _update_freq(self, node):\n        old_freq = node.freq\n        old_list = self.freq_map[old_freq]\n        old_list.remove_node(node)\n        \n        if old_list.size == 0 and old_freq == self.min_freq:\n            self.min_freq += 1\n        \n        node.freq += 1\n        new_freq = node.freq\n        \n        if new_freq not in self.freq_map:\n            self.freq_map[new_freq] = DoublyLinkedList()\n        self.freq_map[new_freq].add_node(node)",
      "difficulty": "hard"
    },
    {
      "id": "C12",
      "title": "52. Minimum Window Substring",
      "description": "\n\n# 52. Minimum Window Substring\n\n## 題目\n給定字串 s 和 t,找出 s 中包含 t 所有字元的最小子字串。若不存在則回傳空字串。\n\n## 面試重點\n此題是**滑動窗口的終極應用**,測試對窗口伸縮條件的精確控制。\n\n核心思路:\n1. 用 HashMap 記錄 t 中每個字元的需求次數\n2. 雙指標維護窗口:\n   - right 擴展窗口,減少對應字元的需求\n   - 當窗口包含所有字元時,left 收縮窗口\n   - 記錄最小窗口\n3. 用 required 變數追蹤還需要多少不同字元\n4. 用 formed 變數追蹤當前窗口已滿足多少字元\n\n面試官會重點觀察:\n- 能否正確處理字元重複:需要計數而非簡單的 Set\n- 窗口有效性判斷:formed == required\n- 何時收縮窗口:找到有效窗口後\n- 如何更新最小窗口:記錄起始位置和長度\n- 優化:用陣列替代 HashMap(若限定字元集)\n- 邊界:t 為空、s 中不包含 t 的所有字元\n\n**常考公司**:\n- Facebook/Meta(滑動窗口高頻)\n- Google、Amazon\n- 字串處理相關公司\n- 文本分析、搜尋引擎\n\n此題展現了**滑動窗口在複雜約束下的應用**,是字串問題的巔峰。\n\n## 複雜度\n- 時間複雜度:O(|S| + |T|)\n- 空間複雜度:O(|S| + |T|)\n\n## Follow-up\n- 若 t 中包含重複字元,演算法需要調整嗎?\n- 若要找所有最小窗口,該如何修改?\n- 若 s 非常長,是資料流,如何處理?\n- 若要找包含 t 中至少 k 個不同字元的最小窗口,如何調整?",
      "code": "from collections import Counter\n\ndef min_window(s: str, t: str) -> str:\n    if not s or not t:\n        return \"\"\n    \n    dict_t = Counter(t)\n    required = len(dict_t)\n    \n    left, right = 0, 0\n    formed = 0\n    window_counts = {}\n    \n    ans = float('inf'), None, None\n    \n    while right < len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        \n        if char in dict_t and window_counts[char] == dict_t[char]:\n            formed += 1\n        \n        while left <= right and formed == required:\n            char = s[left]\n            \n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            window_counts[char] -= 1\n            if char in dict_t and window_counts[char] < dict_t[char]:\n                formed -= 1\n            \n            left += 1\n        \n        right += 1\n    \n    return \"\" if ans[0] == float('inf') else s[ans[1]:ans[2] + 1]",
      "difficulty": "hard"
    },
    {
      "id": "C13",
      "title": "13. Longest Palindromic Substring",
      "description": "# 13. Longest Palindromic Substring\n\n## 題目\n給定字串 s,找出其中最長的回文子字串。\n\n## 面試重點\n此題測試**中心擴展與 Manacher 演算法**,展現從 O(n²) 到 O(n) 的優化思路。\n\n**方法一:中心擴展 O(n²)**\n- 遍歷每個可能的中心點\n- 分奇數長度(單一中心)和偶數長度(雙中心)\n- 從中心向兩邊擴展\n\n**方法二:動態規劃 O(n²)**\n- dp[i][j] = s[i:j+1] 是否為回文\n- 轉移:dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]\n\n**方法三:Manacher 演算法 O(n)**\n- 預處理:在字元間插入特殊符號,統一奇偶\n- 利用回文的對稱性,減少重複計算\n- 維護當前最右回文邊界和中心\n\n面試官會重點觀察:\n- 中心擴展的實作:需要處理奇偶兩種情況\n- DP 方法的填表順序:對角線方向\n- 能否解釋 Manacher 的核心思想:利用對稱性\n- Manacher 的實作難度較高,通常不強求\n- 各方法的空間複雜度差異\n\n**常考公司**:\n- Google、Facebook/Meta\n- Microsoft、Amazon\n- 字串處理常考\n- 通常要求 O(n²) 即可,Manacher 為加分項\n\n此題展現了**從暴力到優化的完整思路**,是字串問題的經典。\n\n## 複雜度\n**中心擴展**:\n- 時間複雜度:O(n²)\n- 空間複雜度:O(1)\n\n**動態規劃**:\n- 時間複雜度:O(n²)\n- 空間複雜度:O(n²)\n\n**Manacher**:\n- 時間複雜度:O(n)\n- 空間複雜度:O(n)\n\n## Follow-up\n- 若要找所有回文子字串的數量,如何計算?\n- 若要找最長回文子序列(不需連續),演算法如何不同?\n- 若字串非常長,如何優化?\n- 能否用後綴陣列或後綴樹解決?",
      "code": "# Method 1: Expand Around Center\ndef longest_palindrome_expand(s: str) -> str:\n    def expand(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    if not s:\n        return \"\"\n    \n    start, end = 0, 0\n    \n    for i in range(len(s)):\n        len1 = expand(i, i)\n        len2 = expand(i, i + 1)\n        max_len = max(len1, len2)\n        \n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    \n    return s[start:end + 1]\n\n# Method 2: Dynamic Programming\ndef longest_palindrome_dp(s: str) -> str:\n    n = len(s)\n    if n < 2:\n        return s\n    \n    dp = [[False] * n for _ in range(n)]\n    start, max_len = 0, 1\n    \n    for i in range(n):\n        dp[i][i] = True\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            \n            if s[i] == s[j]:\n                if length == 2:\n                    dp[i][j] = True\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n                \n                if dp[i][j] and length > max_len:\n                    start = i\n                    max_len = length\n    \n    return s[start:start + max_len]\n\n# Method 3: Manacher's Algorithm\ndef longest_palindrome_manacher(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    t = '#'.join('^{}$'.format(s))\n    n = len(t)\n    p = [0] * n\n    center = right = 0\n    \n    for i in range(1, n - 1):\n        if i < right:\n            p[i] = min(right - i, p[2 * center - i])\n        \n        while t[i + p[i] + 1] == t[i - p[i] - 1]:\n            p[i] += 1\n        \n        if i + p[i] > right:\n            center, right = i, i + p[i]\n    \n    max_len, center_index = max((length, i) for i, length in enumerate(p))\n    start = (center_index - max_len) // 2\n    return s[start:start + max_len]",
      "difficulty": "hard"
    },
    {
      "id": "C14",
      "title": "14. Design Twitter",
      "description": "# 14. Design Twitter\n\n## 題目\n設計簡化版 Twitter,支援以下功能:\n- postTweet(userId, tweetId):發布推文\n- getNewsFeed(userId):取得最新 10 條推文(來自自己和追蹤的人,按時間倒序)\n- follow(followerId, followeeId):追蹤使用者\n- unfollow(followerId, followeeId):取消追蹤\n\n## 面試重點\n此題測試**物件導向設計 + 多路歸併**,是系統設計的入門題。\n\n核心設計:\n1. **User 類別**:\n   - followees:追蹤的人集合\n   - tweets:發布的推文串列(按時間)\n2. **Tweet 類別**:\n   - tweetId, userId, timestamp\n3. **getNewsFeed 實作**:\n   - 收集使用者和其追蹤者的所有推文串列\n   - 用最小堆進行 k-way merge\n   - 取前 10 個\n\n面試官會重點觀察:\n- 資料結構選擇:HashMap 存使用者,Set 存追蹤關係\n- 時間戳的生成:全域計數器\n- getNewsFeed 的效率:避免合併所有推文後再排序\n- 堆的使用:多個已排序串列的合併\n- 邊界處理:使用者不存在、自我追蹤、重複追蹤\n- 擴展性思考:若推文量極大如何優化\n\n**常考公司**:\n- 社交媒體公司(Twitter、LinkedIn、Instagram)\n- Google、Facebook/Meta\n- 系統設計常見起手題\n- OOD 與演算法的結合\n\n此題展現了**如何將實際系統需求轉化為演算法問題**。\n\n## 複雜度\n- postTweet:O(1)\n- follow/unfollow:O(1)\n- getNewsFeed:O(N log K),N 為相關推文數,K 為使用者和追蹤者數量\n\n## Follow-up\n- 若要支援轉推(retweet),如何設計?\n- 若要支援 hashtag 搜尋,資料結構如何調整?\n- 若使用者數量極大,如何分散式儲存?\n- 若要支援即時更新(推送),如何實作?",
      "code": "from collections import defaultdict\nimport heapq\n\nclass Twitter:\n    def __init__(self):\n        self.timestamp = 0\n        self.user_tweets = defaultdict(list)\n        self.user_follows = defaultdict(set)\n    \n    def post_tweet(self, user_id: int, tweet_id: int) -> None:\n        self.user_tweets[user_id].append((self.timestamp, tweet_id))\n        self.timestamp += 1\n    \n    def get_news_feed(self, user_id: int) -> list[int]:\n        heap = []\n        \n        self.user_follows[user_id].add(user_id)\n        \n        for followee_id in self.user_follows[user_id]:\n            if followee_id in self.user_tweets:\n                tweets= self.user_tweets[followee_id]\n                if tweets:\n                    index = len(tweets) - 1\n                    timestamp, tweet_id = tweets[index]\n                    heapq.heappush(heap, (-timestamp, tweet_id, followee_id, index))\n        \n        result = []\n        \n        while heap and len(result) < 10:\n            timestamp, tweet_id, followee_id, index = heapq.heappop(heap)\n            result.append(tweet_id)\n            \n            if index > 0:\n                next_timestamp, next_tweet_id = self.user_tweets[followee_id][index - 1]\n                heapq.heappush(heap, (-next_timestamp, next_tweet_id, followee_id, index - 1))\n        \n        self.user_follows[user_id].discard(user_id)\n        \n        return result\n    \n    def follow(self, follower_id: int, followee_id: int) -> None:\n        if follower_id != followee_id:\n            self.user_follows[follower_id].add(followee_id)\n    \n    def unfollow(self, follower_id: int, followee_id: int) -> None:\n        self.user_follows[follower_id].discard(followee_id)",
      "difficulty": "hard"
    },
    {
      "id": "C15",
      "title": "15. Design Search Autocomplete System",
      "description": "# 15. Design Search Autocomplete System\n\n## 題目\n設計搜尋自動補全系統。給定句子列表和對應的出現次數,實作以下功能:\n- input(c):使用者輸入字元 c\n  - 若 c 是字母,回傳以當前輸入為前綴的前 3 個熱門句子\n  - 若 c 是 '#',儲存當前句子並重置輸入\n  - 熱門度定義:出現次數高優先,次數相同則字典序小優先\n\n## 面試重點\n此題測試**Trie + 堆的組合應用**,是搜尋引擎的核心功能。\n\n核心設計:\n1. **Trie 結構**:\n   - 每個節點存儲經過該節點的所有句子及其次數\n   - 或只存儲經過的句子,查詢時再統計\n2. **input 實作**:\n   - 維護當前輸入字串\n   - 遍歷 Trie 到對應節點\n   - 取該節點的所有句子,排序後回傳前 3 個\n3. **優化**:\n   - 每個 Trie 節點預存 Top 3,空間換時間\n   - 用堆維護 Top K\n\n面試官會重點觀察:\n- Trie 的正確建構:句子而非單字元\n- 排序規則:次數降序,字典序升序\n- 當前輸入的維護:input 之間有狀態\n- '#' 的處理:儲存+重置\n- 空間時間權衡:預存 vs 即時計算\n- 大規模數據下的優化策略\n\n**常考公司**:\n- Google(搜尋引擎核心)\n- Amazon(商品搜尋)\n- Airbnb、Booking.com(地點搜尋)\n- 搜尋相關的所有公司\n\n此題展現了**Trie 在實際系統中的應用**,以及如何處理 Top K 問題。\n\n## 複雜度\n- 初始化:O(N × L),N 為句子數,L 為平均長度\n- input:O(p + m log m),p 為前綴長度,m 為匹配句子數\n- 空間複雜度:O(N × L)\n\n## Follow-up\n- 若句子數量極大,如何優化查詢速度?\n- 若要支援模糊匹配(拼寫錯誤),如何設計?\n- 若要考慮使用者個人化,資料結構如何調整?\n- 分散式環境下,如何分片儲存 Trie?",
      "code": "from collections import defaultdict\nimport heapq\n\nclass AutocompleteSystem:\n    def __init__(self, sentences: list[str], times: list[int]):\n        self.sentence_count = defaultdict(int)\n        for sentence, count in zip(sentences, times):\n            self.sentence_count[sentence] = count\n        \n        self.current_input = \"\"\n    \n    def input(self, c: str) -> list[str]:\n        if c == '#':\n            self.sentence_count[self.current_input] += 1\n            self.current_input = \"\"\n            return []\n        \n        self.current_input += c\n        \n        candidates = []\n        for sentence, count in self.sentence_count.items():\n            if sentence.startswith(self.current_input):\n                candidates.append((-count, sentence))\n        \n        heapq.heapify(candidates)\n        result = []\n        \n        for _ in range(min(3, len(candidates))):\n            count, sentence = heapq.heappop(candidates)\n            result.append(sentence)\n        \n        return result",
      "difficulty": "hard"
    },
    {
      "id": "C16",
      "title": "16. Design In-Memory File System",
      "description": "# 16. Design In-Memory File System\n\n## 題目\n設計記憶體檔案系統,支援以下操作:\n- ls(path):列出路徑下的檔案/目錄,按字典序回傳\n- mkdir(path):創建目錄(含父目錄)\n- addContentToFile(filePath, content):在檔案末尾添加內容,檔案不存在則創建\n- readContentFromFile(filePath):讀取檔案內容\n\n## 面試重點\n此題測試**Trie 的變形應用 + 檔案系統設計**,展現物件導向與資料結構的結合。\n\n核心設計:\n1. **Node 類別**:\n   - isFile:區分檔案與目錄\n   - children:子目錄/檔案的 HashMap\n   - content:若為檔案則儲存內容\n2. **路徑解析**:\n   - split('/') 獲取各層級\n   - 遍歷 Trie 找到對應節點\n3. **mkdir**:\n   - 逐層創建不存在的目錄節點\n4. **ls**:\n   - 若為檔案,回傳檔案名\n   - 若為目錄,回傳所有子項並排序\n\n面試官會重點觀察:\n- Node 設計:如何區分檔案與目錄\n- 路徑解析:處理 \"/\", \"//\", 結尾斜線\n- Trie 遍歷:找到或創建路徑\n- 排序要求:ls 回傳字典序\n- 邊界處理:根目錄、不存在的路徑\n- 並發安全性考慮(進階)\n\n**常考公司**:\n- Dropbox、Google Drive(雲端儲存)\n- Amazon S3 相關\n- 檔案系統公司\n- 系統設計常見題\n\n此題展現了**如何用 Trie 建模階層結構**,類似URL路由、DNS等場景。\n\n## 複雜度\n- ls:O(m + k log k),m 為路徑長度,k 為目錄項數\n- mkdir:O(m)\n- addContentToFile:O(m + n),n 為內容長度\n- readContentFromFile:O(m + n)\n- 空間複雜度:O(N),N 為所有路徑總長度\n\n## Follow-up\n- 若要支援檔案刪除,如何實作?\n- 若要支援軟連結(symbolic link),資料結構如何調整?\n- 若要支援檔案權限,如何設計?\n- 分散式環境下,如何實現?",
      "code": "class FileNode:\n    def __init__(self):\n        self.is_file = False\n        self.children = {}\n        self.content = \"\"\n\nclass FileSystem:\n    def __init__(self):\n        self.root = FileNode()\n    \n    def ls(self, path: str) -> list[str]:\n        node = self.root\n        \n        if path != \"/\":\n            parts = path.split(\"/\")[1:]\n            for part in parts:\n                node = node.children[part]\n        \n        if node.is_file:\n            return [path.split(\"/\")[-1]]\n        \n        return sorted(node.children.keys())\n    \n    def mkdir(self, path: str) -> None:\n        node = self.root\n        parts = path.split(\"/\")[1:]\n        \n        for part in parts:\n            if part not in node.children:\n                node.children[part] = FileNode()\n            node = node.children[part]\n    \n    def add_content_to_file(self, file_path: str, content: str) -> None:\n        node = self.root\n        parts = file_path.split(\"/\")[1:]\n        \n        for part in parts[:-1]:\n            if part not in node.children:\n                node.children[part] = FileNode()\n            node = node.children[part]\n        \n        file_name = parts[-1]\n        if file_name not in node.children:\n            node.children[file_name] = FileNode()\n        \n        file_node = node.children[file_name]\n        file_node.is_file = True\n        file_node.content += content\n    \n    def read_content_from_file(self, file_path: str) -> str:\n        node = self.root\n        parts = file_path.split(\"/\")[1:]\n        \n        for part in parts:\n            node = node.children[part]\n        \n        return node.content",
      "difficulty": "hard"
    },
    {
      "id": "C17",
      "title": "17. Implement Trie (Prefix Tree)",
      "description": "# 17. Implement Trie (Prefix Tree)\n\n## 題目\n實作 Trie(前綴樹),支援以下操作:\n- insert(word):插入單詞\n- search(word):查詢單詞是否存在\n- startsWith(prefix):查詢是否有單詞以該前綴開頭\n\n## 面試重點\n此題測試**Trie 的基本實作**,是字串處理的核心資料結構。\n\n核心設計:\n1. **TrieNode 類別**:\n   - children:HashMap 或陣列(26 個字母)\n   - isEnd:標記是否為單詞結尾\n2. **insert**:\n   - 逐字元遍歷,不存在則創建新節點\n   - 最後節點標記 isEnd = True\n3. **search**:\n   - 逐字元遍歷,不存在則回傳 False\n   - 到達最後檢查 isEnd\n4. **startsWith**:\n   - 逐字元遍歷,能走完即為 True\n\n面試官會重點觀察:\n- TrieNode 設計:children 用 HashMap vs 陣列\n- 陣列優化:若只有小寫字母,用 children[26]\n- isEnd 的作用:區分前綴與完整單詞\n- 空間時間權衡:Trie 空間大但查詢快\n- Trie 的應用場景:自動補全、拼寫檢查、IP路由\n\n**常考公司**:\n- 所有公司的基礎題\n- Google、Microsoft(字串處理)\n- 搜尋引擎相關\n- 通常作為其他題目的子結構\n\n此題是**Trie 的標準模板**,必須熟練掌握。\n\n## 複雜度\n- insert:O(m),m 為單詞長度\n- search:O(m)\n- startsWith:O(m)\n- 空間複雜度:O(ALPHABET_SIZE × N × M),N 為單詞數,M 為平均長度\n\n## Follow-up\n- 若要支援刪除單詞,如何實作?\n- 若要支援萬用字元搜尋(如 \"a.c\"),如何修改?\n- 若要計算每個前綴的單詞數量,資料結構如何調整?\n- 若記憶體有限,如何壓縮 Trie?",
      "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        node = self.root\n        \n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        \n        node.is_end = True\n    \n    def search(self, word: str) -> bool:\n        node = self.root\n        \n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        \n        return node.is_end\n    \n    def starts_with(self, prefix: str) -> bool:\n        node = self.root\n        \n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        \n        return True",
      "difficulty": "hard"
    },
    {
      "id": "C18",
      "title": "18. Trapping Rain Water",
      "description": "# 18. Trapping Rain Water\n\n## 題目\n給定 n 個非負整數表示高度圖,每個柱子寬度為 1,計算下雨後能接多少水。\n\n## 面試重點\n此題測試**雙指標 + 貪心思想**,展現從 O(n) 空間到 O(1) 空間的優化。\n\n**方法一:動態規劃 O(n) 空間**\n- leftMax[i]:位置 i 左邊的最大高度\n- rightMax[i]:位置 i 右邊的最大高度\n- water[i] = min(leftMax[i], rightMax[i]) - height[i]\n\n**方法二:雙指標 O(1) 空間**\n- 用兩個指標從兩端向中間移動\n- 維護 leftMax 和 rightMax\n- 較矮一側決定積水量\n- 移動較矮一側的指標\n\n核心洞察:\n- 每個位置的積水量取決於兩側最大值的較小者\n- 雙指標方法利用:已知一側更高時,另一側的最大值決定積水\n\n面試官會重點觀察:\n- 能否畫圖理解積水原理\n- DP 方法的狀態定義與轉移\n- 雙指標方法的正確性證明\n- 為何移動較矮一側:另一側更高保證了積水高度\n- 邊界處理:兩端不積水\n\n**常考公司**:\n- Google(高頻)\n- Facebook/Meta、Amazon\n- 雙指標技巧的代表題\n- 展現空間優化能力\n\n此題展現了**如何從 DP 優化到雙指標**,是空間優化的經典案例。\n\n## 複雜度\n**DP 方法**:\n- 時間複雜度:O(n)\n- 空間複雜度:O(n)\n\n**雙指標方法**:\n- 時間複雜度:O(n)\n- 空間複雜度:O(1)\n\n## Follow-up\n- 若是二維平面(矩陣),如何計算積水量?\n- 若柱子有不同寬度,演算法如何調整?\n- 若要找積水最多的連續區間,該如何修改?",
      "code": "# Method 1: Dynamic Programming\ndef trap_dp(height: list[int]) -> int:\n    if not height:\n        return 0\n    \n    n = len(height)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    left_max[0] = height[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i - 1], height[i])\n    \n    right_max[n - 1] = height[n - 1]\n    for i in range(n - 2, -1, -1):\n        right_max[i] = max(right_max[i + 1], height[i])\n    \n    water = 0\n    for i in range(n):\n        water += min(left_max[i], right_max[i]) - height[i]\n    \n    return water\n\n# Method 2: Two Pointers\ndef trap(height: list[int]) -> int:\n    if not height:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max = right_max = 0\n    water = 0\n    \n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    \n    return water",
      "difficulty": "hard"
    },
    {
      "id": "C19",
      "title": "19. N-Queens",
      "description": "# 19. N-Queens\n\n## 題目\n在 n×n 棋盤上放置 n 個皇后,使得任意兩個皇后不能互相攻擊(同行、同列、同對角線)。\n回傳所有可能的解決方案。\n\n## 面試重點\n此題是**回溯法的經典應用**,測試對約束條件的建模與剪枝優化。\n\n核心思路:\n1. 逐行放置皇后\n2. 每行嘗試每個列位置\n3. 檢查是否與已放置的皇后衝突:\n   - 同列:用 Set 記錄已使用的列\n   - 主對角線(↘):row - col 相同\n   - 副對角線(↙):row + col 相同\n4. 放置後遞迴下一行,回溯時撤銷\n\n優化技巧:\n- 用 Set 快速檢查衝突\n- 對角線用 row±col 作為唯一標識\n- 不需檢查同行:逐行放置天然避免\n\n面試官會重點觀察:\n- 能否正確建模衝突條件\n- 對角線衝突的數學表達\n- 回溯框架的正確實作\n- 結果格式:字串陣列的生成\n- 時間複雜度分析:O(n!)的理解\n\n**常考公司**:\n- Google(回溯法經典)\n- Microsoft、Amazon\n- 組合優化問題的代表\n- 展現演算法思維深度\n\n此題展現了**如何用回溯法解決組合問題**,是理解回溯的必做題。\n\n## 複雜度\n- 時間複雜度:O(n!)\n- 空間複雜度:O(n),遞迴深度\n\n## Follow-up\n- 若只需要回傳解的數量,能否優化?\n- 若棋盤大小非常大(如 100×100),如何處理?\n- 若要放置 k 個皇后而非 n 個,演算法如何調整?\n- 能否用位運算優化衝突檢查?",
      "code": "def solve_n_queens(n: int) -> list[list[str]]:\n    result = []\n    board = [['.'] * n for _ in range(n)]\n    cols = set()\n    diag1 = set()\n    diag2 = set()\n    \n    def backtrack(row):\n        if row == n:\n            result.append([''.join(row) for row in board])\n            return\n        \n        for col in range(n):\n            if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                continue\n            \n            board[row][col] = 'Q'\n            cols.add(col)\n            diag1.add(row - col)\n            diag2.add(row + col)\n            \n            backtrack(row + 1)\n            \n            board[row][col] = '.'\n            cols.remove(col)\n            diag1.remove(row - col)\n            diag2.remove(row + col)\n    \n    backtrack(0)\n    return result",
      "difficulty": "hard"
    },
    {
      "id": "C20",
      "title": "20. Word Search II",
      "description": "# 20. Word Search II\n\n## 題目\n給定 m×n 字母網格 board 和字串列表 words,找出所有在網格中出現的單詞。\n單詞路徑可以由相鄰格子(上下左右)的字母組成,同一格子不能重複使用。\n\n## 面試重點\n此題測試**Trie + DFS 回溯的組合**,是優化搜尋的進階技巧。\n\n核心思路:\n1. **建立 Trie**:將所有 words 插入 Trie\n2. **DFS 搜尋**:\n   - 遍歷 board 每個格子作為起點\n   - DFS 時同時在 Trie 中前進\n   - 若到達 Trie 的 isEnd,找到一個單詞\n3. **優化**:\n   - 找到單詞後,將 Trie 中的 isEnd 標記為 False,避免重複\n   - 剪枝:若 Trie 節點無子節點,提前返回\n\n關鍵優化:\n- 用 Trie 而非逐一搜尋每個單詞:共享前綴,減少重複計算\n- DFS 過程中同時在 Trie 和 board 中前進\n- 及時標記已找到的單詞,避免重複\n\n面試官會重點觀察:\n- 能否識別這需要 Trie 優化\n- DFS 與 Trie 遍歷的同步\n- 訪問標記:臨時修改 board 或用 visited 集合\n- 去重:同一單詞不重複計入\n- Trie 的動態修改:找到後刪除或標記\n\n**常考公司**:\n- Google(Trie + DFS 綜合)\n- Amazon(Word Search 系列)\n- 遊戲公司(拼字遊戲相關)\n- 難度極高,綜合考察\n\n此題展現了**Trie 如何優化多模式匹配**,是 Trie 應用的巔峰。\n\n## 複雜度\n- 時間複雜度:O(m × n × 4^L),L 為最長單詞長度\n- 空間複雜度:O(N × L),N 為單詞數,L 為平均長度\n\n## Follow-up\n- 若 board 非常大,如何分散式處理?\n- 若單詞表動態變化,如何優化?\n- 若允許對角線移動,演算法如何調整?\n- 若同一格子可以重複使用,會有什麼問題?",
      "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\nclass Solution:\n    def find_words(self, board: list[list[str]], words: list[str]) -> list[str]:\n        root = TrieNode()\n        \n        for word in words:\n            node = root\n            for char in word:\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.word = word\n        \n        m, n = len(board), len(board[0])\n        result = []\n        \n        def dfs(i, j, node):\n            char = board[i][j]\n            \n            if char not in node.children:\n                return\n            \n            next_node = node.children[char]\n            \n            if next_node.word:\n                result.append(next_node.word)\n                next_node.word = None\n            \n            board[i][j] = '#'\n            \n            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '#':\n                    dfs(ni, nj, next_node)\n            \n            board[i][j] = char\n            \n            if not next_node.children:\n                del node.children[char]\n        \n        for i in range(m):\n            for j in range(n):\n                dfs(i, j, root)\n        \n        return result",
      "difficulty": "hard"
    }
  ]
}