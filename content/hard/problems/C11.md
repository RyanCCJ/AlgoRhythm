# 11. LFU Cache

## 題目
設計一個 LFU(Least Frequently Used)快取,支援 get 和 put 操作,兩者都需在 O(1) 時間完成。
容量固定,達到容量時移除使用頻率最低的項目,若頻率相同則移除最久未使用的。

## 面試重點
此題是**多層資料結構設計**的巔峰,測試複雜系統的建模與維護能力。

核心設計:
1. **key_map**:key → Node,存儲 key 到節點的映射
2. **freq_map**:frequency → DoublyLinkedList,存儲每個頻率的所有節點
3. **min_freq**:當前最小頻率,用於淘汰

關鍵操作:
- **get**:頻率 +1,移動節點到新頻率鏈表
- **put**:
  - 若 key 存在:更新值,頻率 +1
  - 若 key 不存在:
    - 容量滿:刪除 min_freq 鏈表的尾節點
    - 插入新節點到頻率 1 的鏈表
    - 更新 min_freq = 1

面試官會重點觀察:
- 能否設計出正確的資料結構組合
- min_freq 的維護:何時更新為 1,何時 +1
- 頻率變化時的鏈表操作:從舊頻率移除,加入新頻率
- 雙向鏈表的作用:O(1) 刪除節點
- 空鏈表的處理:刪除空的頻率鏈表
- 與 LRU 的對比:LFU 更複雜,需要多一層頻率索引

**常考公司**:
- Google(系統設計高頻)
- Facebook/Meta(cache 相關)
- Amazon、Microsoft
- CDN 公司、快取服務公司
- 比 LRU 更難,展現設計能力

此題展現了**如何通過組合多個資料結構達成複雜需求**,是系統設計的微縮版。

## 複雜度
- 時間複雜度:get 和 put 都是 O(1)
- 空間複雜度:O(capacity)

## Follow-up
- 若要支援批次操作,如何優化?
- 若容量非常大,分散式環境如何實作?
- 若要支援過期時間(TTL),資料結構如何調整?
- 與 LRU 相比,LFU 的優缺點是什麼?