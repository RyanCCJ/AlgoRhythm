# 9. Merge K Sorted Lists

## 題目
給定 k 個已排序的鏈結串列陣列,將它們合併成一個已排序的鏈結串列。

## 面試重點
此題測試**堆(Heap)的應用與分治思想**,是多路歸併的經典問題。

核心思路:
**方法一:最小堆**
- 將每個串列的頭節點放入最小堆
- 每次取出最小節點,將其 next 放入堆
- 時間 O(N log k),N 為總節點數

**方法二:分治合併**
- 兩兩合併串列,類似歸併排序
- 第一輪:k 個串列合併成 k/2 個
- 持續合併直到剩一個
- 時間 O(N log k)

**方法三:逐一合併**
- 依序合併每個串列
- 時間 O(N × k),較慢

面試官會重點觀察:
- 能否快速想到堆方法:k 路歸併的標準解法
- Python heapq 的使用:需要自定義比較或用 (val, node) 元組
- 分治方法的實作:類似歸併排序的樹狀合併
- 空間複雜度分析:堆方法 O(k),分治方法 O(log k)遞迴深度
- 優化:能否避免空串列進堆

**常考公司**:
- Google(高頻題)
- Amazon(merge 相關常客)
- Microsoft、LinkedIn
- 系統設計中的多路歸併場景
- 資料庫公司(外部排序)

此題展現了**堆在多路選擇中的威力**,是理解優先佇列應用的關鍵。

## 複雜度
**最小堆方法**:
- 時間複雜度:O(N log k)
- 空間複雜度:O(k)

**分治方法**:
- 時間複雜度:O(N log k)
- 空間複雜度:O(log k)

## Follow-up
- 若 k 非常大,無法全部載入記憶體,如何處理?
- 若要找第 n 小的元素而非全部合併,如何優化?
- 若串列不是鏈結串列而是陣列,方法有何不同?
- 在外部排序中,如何應用這個演算法?