# 5. Serialize and Deserialize Binary Tree

## 題目
設計演算法將二元樹序列化為字串,並能從字串反序列化回二元樹。
序列化格式可自行定義。

## 面試重點
此題測試**樹的遍歷與編碼設計**,是系統設計與資料持久化的基礎。

核心思路:
**方法一:前序遍歷(DFS)**
- 序列化:前序遍歷,空節點用特殊符號(如 'null')
- 反序列化:依序讀取,遞迴重建
- 優點:簡潔,易於實作

**方法二:層序遍歷(BFS)**
- 序列化:層序遍歷,記錄所有節點(包括 null)
- 反序列化:用佇列重建
- 優點:直觀,與樹的視覺表示一致

面試官會重點觀察:
- 能否設計簡潔且無歧義的編碼格式
- 為何需要記錄空節點:區分左右子樹
- 序列化與反序列化的對稱性
- 邊界處理:空樹、只有根節點、斜樹
- 分隔符的選擇:逗號、空格等
- 能否處理節點值包含分隔符的情況

**常考公司**:
- Google(分散式系統數據序列化)
- Amazon(資料持久化)
- Database 公司(儲存引擎設計)
- 系統設計常見子問題

此題展現了**資料結構與字串編碼的結合**,是實際工程中的常見需求。

## 複雜度
**前序遍歷**:
- 時間複雜度:O(n)
- 空間複雜度:O(n)

**層序遍歷**:
- 時間複雜度:O(n)
- 空間複雜度:O(n)

## Follow-up
- 若要最小化序列化後的字串長度,該如何優化?
- 若二元樹是 BST,能否利用其性質減少編碼長度?
- 若要支援流式反序列化(邊接收邊重建),該如何設計?
- 若節點值可能包含特殊字元,如何處理?