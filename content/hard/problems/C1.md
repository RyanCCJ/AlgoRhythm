# 1. Edit Distance

## 題目
給定兩個字串 word1 和 word2,計算將 word1 轉換成 word2 所需的最少操作次數。
允許的操作:插入字元、刪除字元、替換字元。

## 面試重點
此題是**經典二維 DP 問題**,測試對編輯距離(Levenshtein Distance)的理解,是自然語言處理與字串相似度的基礎演算法。

核心思路:
- 狀態定義:dp[i][j] = word1[0:i] 轉換為 word2[0:j] 的最少操作數
- 狀態轉移:
  - 若 word1[i-1] == word2[j-1]:dp[i][j] = dp[i-1][j-1]
  - 否則:dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    - dp[i-1][j] + 1:刪除 word1[i-1]
    - dp[i][j-1] + 1:插入 word2[j-1]
    - dp[i-1][j-1] + 1:替換 word1[i-1] 為 word2[j-1]
- 初始化:dp[0][j] = j, dp[i][0] = i

面試官會重點觀察:
- 能否正確畫出 DP 表格並理解每個格子的含義
- 三種操作如何對應到 DP 轉移
- 邊界初始化的理解:空字串到任意字串需要全部插入/刪除
- 空間優化:能否用滾動陣列降至 O(min(m,n))
- 實際應用理解:拼寫檢查、DNA 序列比對、版本控制 diff

**常考公司**:
- Google(搜尋糾錯、自然語言處理)
- Microsoft(Office 拼寫檢查)
- AI Startups(NLP 相關)
- 生物科技公司(基因序列比對)

此題是**字串 DP 的巔峰之作**,理解它能掌握大部分二維 DP 問題。

## 複雜度
- 時間複雜度:O(m × n)
- 空間複雜度:O(m × n),可優化至 O(min(m, n))

## Follow-up
- 若只允許插入和刪除,演算法如何簡化?
- 若不同操作有不同代價(加權編輯距離),如何修改?
- 若要輸出具體的操作序列,該如何回溯?
- 若字串非常長,如何做記憶體優化?