# 6. LRU Cache

## 題目
設計一個 LRU(Least Recently Used)快取,支援 get 和 put 操作,兩者都需要在 O(1) 時間完成。
容量固定,當達到容量時,移除最久未使用的項目。

## 面試重點
此題是**雙向鏈結串列 + HashMap** 組合的經典應用,測試複雜資料結構的設計能力。核心設計:
1. HashMap 提供 O(1) 的 key 查找
2. 雙向鏈結串列維護訪問順序:最近使用的在頭部,最久未使用的在尾部
3. 每次訪問都將節點移到頭部,容量滿時移除尾部節點

面試官會重點觀察:
- 能否解釋為何需要雙向鏈結串列(單向無法 O(1) 刪除)
- 節點移動的實作:先刪除,再插入頭部
- dummy head 和 dummy tail 的使用,簡化邊界處理
- HashMap 和鏈結串列的同步更新:刪除節點時要同時從兩者移除
- 區分「訪問」和「插入」的邏輯複用

這是系統設計中常見的快取淘汰策略,展現了**如何用組合資料結構達到多維度的 O(1) 操作**。

## 複雜度
- 時間複雜度:get 和 put 都是 O(1)
- 空間複雜度:O(capacity)

## Follow-up
- 若要實作 LFU(Least Frequently Used)快取,該如何設計?
- 若容量非常大,如何處理記憶體限制?
- 在多執行緒環境下,如何保證執行緒安全?