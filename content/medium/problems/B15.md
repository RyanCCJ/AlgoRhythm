
# 15. Coin Change

## 題目
給定不同面額的硬幣 coins 和總金額 amount,計算組成該金額所需的最少硬幣數。
若無法組成,回傳 -1。假設每種硬幣數量無限。

## 面試重點
此題是**完全背包問題**的經典應用,測試動態規劃的狀態定義與轉移方程設計。

核心思路:
- 狀態定義:dp[i] = 組成金額 i 所需的最少硬幣數
- 初始狀態:dp[0] = 0,其餘設為無窮大
- 狀態轉移:dp[i] = min(dp[i], dp[i - coin] + 1),對所有 coin ≤ i
- 最終答案:dp[amount],若仍為無窮大則無解

面試官會重點觀察:
- 能否正確定義狀態與轉移方程
- 初始值設置:dp[0] = 0 的理解(組成 0 需要 0 個硬幣)
- 為何是完全背包而非 0-1 背包:硬幣可重複使用
- 迴圈順序:外層 amount,內層 coins(或反過來都可)
- 邊界檢查:coin <= i 才更新
- 空間優化:能否用一維陣列而非二維

此題展現了**DP 狀態設計的一般流程**:定義狀態 → 找轉移 → 確定邊界 → 計算順序。

## 複雜度
- 時間複雜度:O(amount × len(coins))
- 空間複雜度:O(amount)

## Follow-up
- 若要輸出具體的硬幣組合,該如何修改?
- 若有硬幣數量限制,演算法如何調整?(變成 0-1 背包)
- 若要計算組成金額的方法數(而非最少硬幣數),該如何修改?