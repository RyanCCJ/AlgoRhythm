# 18. Combination Sum

## 題目
給定無重複元素的陣列 candidates 和目標值 target,找出所有和為 target 的數字組合。
同一數字可以重複選擇任意次。

## 面試重點
此題是**回溯法(Backtracking)**的經典應用,測試遞迴樹的剪枝與去重。

核心思路:
- 遞迴探索所有可能的組合
- 每次選擇一個數字,遞迴尋找剩餘 target
- 剪枝:若當前和已超過 target,停止探索
- 去重:從當前索引開始選擇,避免 [2,3] 和 [3,2] 重複

回溯模板:
```
def backtrack(start, path, remain):
    if remain == 0:
        result.append(path[:])  # 找到解
        return
    if remain < 0:
        return  # 剪枝
    
    for i in range(start, len(candidates)):
        path.append(candidates[i])
        backtrack(i, path, remain - candidates[i])  # i 而非 i+1,可重複
        path.pop()  # 回溯
```

面試官會重點觀察:
- 能否正確實作回溯框架:選擇 → 遞迴 → 撤銷選擇
- 去重邏輯:start 參數的作用,為何是 i 而非 i+1
- 剪枝優化:提前終止無效分支
- path 的複製:append(path[:]) vs append(path)
- 時間複雜度分析:O(2^n) 的理解(決策樹的分支數)

此題展現了**回溯法的標準模板**,適用於組合、排列、子集等問題。

## 複雜度
- 時間複雜度:O(2^target),最壞情況
- 空間複雜度:O(target),遞迴深度

## Follow-up
- 若陣列包含重複元素,如何去重?
- 若限制每個數字最多使用 k 次,該如何修改?
- 若要找組合數而非所有組合,能否用 DP 優化?