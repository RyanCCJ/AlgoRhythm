# 19. Permutations

## 題目
給定無重複數字的陣列 nums,回傳所有可能的全排列。

## 面試重點
此題測試**回溯法的排列變形**,與組合問題的關鍵差異是**順序敏感**。

核心差異:
- 組合:[1,2] 和 [2,1] 視為相同,用 start 參數避免重複
- 排列:[1,2] 和 [2,1] 視為不同,需要 used 陣列標記已使用元素

回溯模板:
```
def backtrack(path):
    if len(path) == n:
        result.append(path[:])
        return
    
    for i in range(n):
        if used[i]:
            continue  # 已使用,跳過
        
        used[i] = True
        path.append(nums[i])
        backtrack(path)
        path.pop()
        used[i] = False
```

面試官會重點觀察:
- 能否區分排列與組合問題
- used 陣列的作用:防止同一元素在一個排列中重複使用
- 為何不用 start 參數:排列需要回頭選擇
- 終止條件:len(path) == n
- 空間優化:能否用 path 的 Set 檢查替代 used 陣列
- 若陣列有重複元素,去重策略(排序 + 剪枝)

此題展現了**排列問題的標準回溯模板**,是理解回溯法的關鍵題目。

## 複雜度
- 時間複雜度:O(n × n!),n! 個排列,每個複製需要 O(n)
- 空間複雜度:O(n),遞迴深度

## Follow-up
- 若陣列包含重複元素,如何去重?
- 若要找下一個排列(字典序),該用什麼演算法?
- 若限制只能生成 k 個元素的排列,該如何修改?