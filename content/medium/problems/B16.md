# 16. Longest Increasing Subsequence

## 題目
給定整數陣列 nums,找出最長嚴格遞增子序列的長度。
子序列不需要連續,但必須保持相對順序。

## 面試重點
此題有兩種解法,測試**DP 優化與二分搜尋的結合**。

**方法一:動態規劃 O(n²)**
- 狀態定義:dp[i] = 以 nums[i] 結尾的最長遞增子序列長度
- 狀態轉移:dp[i] = max(dp[j] + 1),其中 j < i 且 nums[j] < nums[i]
- 直觀但效率較低

**方法二:DP + 二分搜尋 O(n log n)**
- 維護陣列 tails,tails[i] = 長度為 i+1 的遞增子序列的最小尾部元素
- tails 陣列保持有序,用二分搜尋找插入位置
- 核心思想:貪心地保持每個長度的子序列盡可能小的尾部

面試官會重點觀察:
- 能否實作基礎的 O(n²) DP
- 能否理解 O(n log n) 方法的核心思想:
  - 為何維護「最小尾部元素」
  - 為何可以用二分搜尋
  - tails 陣列的語義:不是實際的子序列,而是各長度子序列的最優尾部
- 二分搜尋的變形:找第一個 >= target 的位置
- 最終答案是 tails 的長度,而非某個 dp 值

此題展現了**如何通過輔助資料結構與二分搜尋優化 DP**。

## 複雜度
- DP:時間 O(n²);空間 O(n)
- DP + 二分:時間 O(n log n);空間 O(n)

## Follow-up
- 若要輸出最長遞增子序列本身,該如何修改?
- 若要找最長非嚴格遞增(允許相等),演算法如何調整?
- 若要找最長遞減子序列,該如何修改?